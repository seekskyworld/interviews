# 一，哈希

## [1. 两数之和](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

 

**提示：**

- `2 <= nums.length <= 104`

- `-109 <= nums[i] <= 109`

- `-109 <= target <= 109`

  ```java
  class Solution {
      public int[] twoSum(int[] nums, int target) {
          int n = nums.length;
          for (int i = 0; i < n; ++i) {
              for (int j = i + 1; j < n; ++j) {
                  if (nums[i] + nums[j] == target) {
                      return new int[]{i, j};
                  }
              }
          }
          return new int[0];
      }
  }
  
  ```



## [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

 

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**示例 2:**

```
输入: strs = [""]
输出: [[""]]
```

**示例 3:**

```
输入: strs = ["a"]
输出: [["a"]]
```

 

**提示：**

- `1 <= strs.length <= 104`

- `0 <= strs[i].length <= 100`

- `strs[i]` 仅包含小写字母

  ```java
  class Solution {
      public List<List<String>> groupAnagrams(String[] strs) {
       Map<String,List<String>> map = new HashMap<String, List<String>>();
      for(String str:strs){
         char[] array  = str.toCharArray();
         Arrays.sort(array);
          String key = new String(array);
          List<String>list = map.getOrDefault(key , new ArrayList<String>());
          list.add(str);
          map.put(key,list);
      }
      return new  ArrayList<List<String>>(map.values());
      }
  }
  ```

  

## [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

 

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

 

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> num_set = new HashSet<Integer>();
        for (int num : nums) {
            num_set.add(num);
        }

        int longestStreak = 0;

        for (int num : num_set) {
            if (!num_set.contains(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.contains(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = Math.max(longestStreak, currentStreak);
            }
        }

        return longestStreak;
    }
}

```

# 二，双指针

## [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

 

**提示**:

- `1 <= nums.length <= 104`

- `-231 <= nums[i] <= 231 - 1`

  ```java
  class Solution {
  	public void moveZeroes(int[] nums) {
  		if(nums==null) {
  			return;
  		}
  		//第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]
  		int j = 0;
  		for(int i=0;i<nums.length;++i) {
  			if(nums[i]!=0) {
  				nums[j++] = nums[i];
  			}
  		}
  		//非0元素统计完了，剩下的都是0了
  		//所以第二次遍历把末尾的元素都赋为0即可
  		for(int i=j;i<nums.length;++i) {
  			nums[i] = 0;
  		}
  	}
  }
  ```


## [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

 

**示例 1：**

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

 

**提示：**

- `n == height.length`
- `2 <= n <= 105`
- `0 <= height[i] <= 104`

 解题思路

 使用双指针进行遍历，算出来的结果=(right-left)✖矮一点的木版数字

 依次比较 板的高低,left++,right--

```java
class Solution {
    public int maxArea(int[] height) {
        // 初始化左右指针和最大面积
        int i = 0, j = height.length - 1, res = 0;
        
        // 当左指针小于右指针时执行循环
        while(i < j) {
            // 计算当前两个指针围成的容器的面积，并更新最大面积
            // 高度取两个指针中较小的值，宽度为两个指针之间的距离
            res = height[i] < height[j] ? 
                Math.max(res, (j - i) * height[i++]): // 若左指针对应的高度较低，则向右移动左指针
                Math.max(res, (j - i) * height[j--]); // 若右指针对应的高度较低，则向左移动右指针
        }
        // 返回最大面积
        return res;
    }
}
```



## [15. 三数之和](https://leetcode.cn/problems/3sum/)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

 

 

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

 

**提示：**

- `3 <= nums.length <= 3000`

- `-105 <= nums[i] <= 105`

  解题思路
  
  1.排序数组nums，使用Arrays.sort(nums);
  
  输入：nums = [-1,0,1,2,-1,-4],输出：[-4,-1,-1,0,1,1,2,]
  
  2.由于x,y,z,都必须不同，主要顺序由i决定，再定义另外两个指针left和right，
  
  进行一次for循环，每一个i的数字就排除所有的可能性
  
  先大概写一下
  
  ```java
  class Solution {
      public List<List<Integer>> threeSum(int[] nums) {
  		List<List<Integer>> result = new ArrayList<>;//先定义返回函数
          Arrays.sort(nums);							//排序一下
          for(int i =0;i<nums.length-2;i++){			//长度为6-2=4，只访问到nums[3],i一共是四次循          						
              if (i > 0 && nums[i] == nums[i - 1])	// 重复的固定值
                  continue;							//直接跳过本次循环
     left = i+1;right = nums.length-1；				//left初始值比i大，right等于最后一个元素
    int sum = nums[i] + nums[left] + nums[right];		//三个加起来等于0就加入下面list集合
   result.add(Arrays.asList(nums[i], nums[left], nums[right])); //加入result集合
          }
          return result;								//写了返回再说
      }
  }
  ```
  
  上面写了循环一次的一种可能性，下面完善可能性，排除掉重复可能性
  
  ```java
  class Solution {
      public List<List<Integer>> threeSum(int[] nums) {
  		List<List<Integer>> result = new ArrayList<>;//先定义返回函数
          Arrays.sort(nums);							//排序一下
          for(int i=0 ;i<nums.length-2;i++){			//长度为6-2=4，只访问到nums[3],i一共是四次循          						
              if (i > 0 && nums[i] == nums[i - 1])	// 重复的固定值
                  continue;							//直接跳过本次循环
      left = i+1;right = nums.length-1；				//left初始值比i大，right等于最后一个元素        
              while(left<right){						//指证相碰退出循环
    int sum = nums[i] + nums[left] + nums[right];		//三个加起来等于0就加入下面result集合
                  if(sum==0)													//判断一下是不是0
   result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                  else if(sum<0)												//大于0
                   left++;
                  else 														//小于0
                  right--;
                  
              }
          }
          return result;								//写了返回再说
      }
  }
  ```
  
  

​	因为右边是最大值，所以只要小于0就left++，因为只有left更大，sum才会更大，才有机会接近0

大于0就right---，因为只有right更小，sum才会更小，才有机会接近0

编写等于零的时候，判断其他可能性

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();//先定义返回函数
        Arrays.sort(nums);							//排序一下
        for(int i=0 ;i<nums.length-2;i++){			//长度为6-2=4，只访问到nums[3],i一共是四次循
            if (i > 0 && nums[i] == nums[i - 1])	// 重复的固定值
                continue;							//直接跳过本次循环
           int left = i+1;int right = nums.length-1;				//left初始值比i大，right等于最后一个元素
            while(left<right){						//指证相碰退出循环
                int sum = nums[i] + nums[left] + nums[right];				//三个加起来等于0就加入下面result集合
               
                if(sum==0){										 //判断一下是不是0			
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    while (left < right && nums[left] == nums[left + 1])					 // 避免重复的左指针值
                        left++;
                    while (left < right && nums[right] == nums[right - 1])					// 避免重复的右指针值
                        right--;
                    //都不相同，那我就默认这两个指针的下一个元素都是不同的，同时+1-1再判断下其他可能性
                    left++;
                    right--;
                		}
                else if (sum < 0)                      		// 小于0，增加三个数的和
                    left++;
                else                                		 // 大于0，减小三个数的和
                    right--;

            }
        }
        return result;								//写了返回再说
    }
}
```

## [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

 

**提示：**

- `n == height.length`
- `1 <= n <= 2 * 104`
- `0 <= height[i] <= 105`

1，解题思路，可以用两个指针来解决，分别是left和right

left指针和right指针分别对应左右两边的木板高度，让木板小的那个指针一直++，

因为水会从矮的那一边溢出，然后更新preMax或sufMax的木板最大高度。

再用木板最大高度减去，当前木板高度，就可以得到雨水的体积，再把体积加入总数ans

```java
    public int trap(int[] height) {
        // 初始化结果变量为0，左指针为数组起始位置，右指针为数组末尾位置，以及左右两侧的最大高度
        int ans = 0, left = 0, right = height.length - 1, preMax = 0, sufMax = 0;
        // 只要左指针小于右指针，就继续循环
        while (left < right) {
            // 更新左侧的最大高度为当前左侧的最大高度和左指针对应高度的较大值
            preMax = Math.max(preMax, height[left]);
            // 更新右侧的最大高度为当前右侧的最大高度和右指针对应高度的较大值
            sufMax = Math.max(sufMax, height[right]);
            // 如果左侧的最大高度小于右侧的最大高度，说明左侧能够接住的水量受限于左侧的最大高度
            // 否则，右侧能够接住的水量受限于右侧的最大高度
            // 根据较小的最大高度来计算当前位置能够接住的水量，并更新结果变量
            ans += preMax < sufMax ? preMax - height[left++] : sufMax - height[right--];
        }
        return ans;
    }
```



# 三，滑动窗口

## [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的最长子串的长度。



 

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

 

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

```java
class Solution {
        public int lengthOfLongestSubstring(String s) {
            //创建left和right指针，分别对应
            //创建一个map集合存入字符串的Character和索引值
            //right++，判断当前索引是否在map集合里，如果在就更新left指针
            int left=0,right = 0;
            Map<Character,Integer> map = new HashMap<>();
            int sum = 0;
            for(;right<s.length();right++){
                if(map.containsKey(s.charAt(right))){
      // 更新左指针的位置，确保左指针指向的字符不在当前子串中，注意使用Math.max比较left大小
      //如果不比较，假设abba，right指向b时2，left也指向b，2，但是当right指向a时索引为3，left反而变小了，变成0+1=1，3-1+1=3，答案错误
                    left = Math.max(left,map.get(s.charAt(right))+1);
                }
                 // 将字符及其索引位置存入HashMap中
                map.put(s.charAt(right),right);
                // 更新最长子串的长度
                sum = Math.max(sum,(right-left+1));
            }
            return sum;// 返回结果
        }
}
```

## [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

 

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

 

**提示:**

- `1 <= s.length, p.length <= 3 * 104`

- `s` 和 `p` 仅包含小写字母

  1.解题思路

  把两个字符串映射在两个int数组中。大小为26，刚好为26个小写字母的长度。

  两个数组假设为sCount和pCount。长度以小的那种字符串为主，然后进行逐一比较

  sCount假设为abcabc

  只取三位为从a开始为1110000......

  只取三位从b开始为0111000......

  pCount假设为abc

  abc为1110000......

  设置两个指针分别对应left和right

  for 循环中的 i 为遍历sCount的长度

  先写一下

  ```java
  class Solution {
      public List<Integer> findAnagrams(String s, String p) {
        List<Integer> list =  new ArrayList<>();
  		int[]sCount = new int[26];
          int[]pCount = new int[26];
          for(int i = 0 ;i<p.length();i++){//遍历小字符串
              int num1  = s.charAt(i)-'a';//利用char字符的ASCII码值判断在数组哪个位置加一，A为65，小a为97，z为122
              int num2  = p.charAt(i)-'a';//a-a=0,z-a=25,此处为索引值，其实已经是第26了
              sCount[num1]++;             //分别加一
              sCount[num2]++;
          }
      
          for(int i = 0 ;i<s.length();i++){			//这次遍历大字符串s
    			 if(Arrays.equals(sCount, pCount)){
                   list.add(i)						//如果一样就加入当前索引
               }
          }
          return list ;                   	//先返回
      }
  }
  ```

  

  完善逻辑，大字符串是变化的，那么他的sCout数组也是变化的，要加入双指针，进行滑动窗口的框选

  ```java
   public List<Integer> findAnagrams(String s, String p) {
                      List<Integer> list =  new ArrayList<>();
       
              if (s == null || p == null || s.length() < p.length()) 	// 排除意外条件
                  return listt;
  
                      int[]sCount = new int[26];			//构建26位字母的数组表，由索引来分辨是哪个字母，然后就加一
                      int[]pCount = new int[26];
                      for(int i = 0 ;i<p.length();i++){
                          int num1  = s.charAt(i)-'a';//利用char字符的ASCII码值判断在数组哪个位置加一，A为65，小a为97，z为122
                          int num2  = p.charAt(i)-'a';//a-a=0,z-a=25,此处为索引值，其实已经是第26了
                          sCount[num1]++;             //分别加一
                          pCount[num2]++;
                      }
                      if(Arrays.equals(sCount, pCount)){//先判断一下索引0是否一样
                          list.add(0);
                      }
                      int left = 0;								//构建浮动窗口
                      int right =left+ p.length()-1;
                      while(true){								//这次遍历大字符串s
                          sCount[s.charAt(left) - 'a']--;			//删除浮动窗口中第一个元素的值，在大窗口中
                          left++;
                          right++;
                          if(right >= s.length())					//大数组剩余未判断元素个数 小于小数组的元素个数，直接返回
                              break;
  
                          sCount[s.charAt(right)-'a']++;		//添加浮动窗口中最后一个元素的值，在大窗口中
                          if(Arrays.equals(sCount, pCount)){
                              list.add(left)		;				//如果一样就加入当前索引
                          }
  
  
                      }
                      return list ;                   	//先返回
                  }
  
  ```

  

# 四，子串

## [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

  给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

  子数组是数组中元素的连续非空序列。

   

  **示例 1：**

  ```
  输入：nums = [1,1,1], k = 2
  输出：2
  ```

  **示例 2：**

  ```
  输入：nums = [1,2,3], k = 3
  输出：2
  ```

   

  **提示：**

  - `1 <= nums.length <= 2 * 104`
  
  - `-1000 <= nums[i] <= 1000`
  
  - `-107 <= k <= 107`
  
    1.解题思路，由于子数组是数组中元素的连续非空序列，所以创建一个数组，存入前缀和表，
  
    前缀和表第一个数字要设置为0，要比正常表多一位，下面进行假设


​        
​      
​    ```
​    nums有6个数字分别为 1，1，0，-2，4，1
​    
​     那么前缀和表就是 0，1，2，2，0，4，5
​    
​        当前前缀和减去k(比如是2)，所得到的数，可以列一个表
​    
​     对应得到的差值表 0,-1, 0,0,-2,2,3
​    ```
​      
​    这个表的数字
​      
​    比如第三个0，对应前缀和表的第一个0，就可以得到前面有数字相加等于2，分别是nums第一个1和第二个1
​      
​    比如第四个0，还是对应前缀和表的第一个0，就可以得到前面有数字相加等于2，分别是第一个1和第二个1和第三个0
​    比如第五个0，对应前缀和表的第三个和第四个2，就可以得到前面有数字相加等于2，分别是0，2，-4，和   2，-4
​      
​    但是如果nums和k全为0呢，那不就是前面的任意组合都是0么，所以我们需要定义一个hash表，记录前面前缀和出现的个数
​      
​    直接写出来

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int[] prefixSum = new int[nums.length+1];  //前缀和表比nums数组大一位
        prefixSum[0] = 0;								//第一位为0
        for (int i = 0; i < nums.length; i++) {			//直接算出前缀和表
            prefixSum[i + 1] = prefixSum[i] + nums[i];	//i+1的值，等于前面的和与当前数字相加
        }
        int sum = 0 ;										
        Map<Integer, Integer>map=  new HashMap<>();	//前缀和表遍历存的数减k，如果表中有，那么就有一个子集是
        for(int i=0 ;i<prefixSum.length;i++){				//这里是遍历的前缀和表
            sum = sum + map.getOrDefault(prefixSum[i]-k,0); // 如果表里有与当前prefixSum[i]-k的差相等，则加上它的个数
            												//考虑的是全为0的情况，那不就是前面的任意组合都是0么
            //由于第一个数0不在nums数组中，所以顺序放后面也没问题
            map.put(prefixSum[i] ,	map.getOrDefault(prefixSum[i],0)+1	); //添加进表，前面是值，后面是个数

        }
        return sum;											//返回
    }

}
```

# 五，普通数组

## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。



**子数组**

是数组中的一个连续部分。



 

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```

 

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

 

**进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

1，解题思路

定义两个数分别为最大子数组和，当前字数组和

对nums数组进行遍历，每次 i 为nums数组的下标，为本身和之前的数字之和

```java
class Solution {
       public int maxSubArray(int[] nums) {
        //创建两个变量，一个遍历到的一小节子数组之和，另一个是最大和
        //如果null或者length为0直接返回0
       int n = nums.length;
        if(nums==null || n==0)
        return 0 ;
        int sum=nums[0];            
        int maxsum = nums[0];       //都初始化为nums[0]，遍历从nums[1]开始
        for(int i =1;i<n;i++){
         //如果当前nums[i]就比前面的和加起来更大可以直接覆盖
            sum = Math.max(nums[i],sum+nums[i]);
            maxsum = Math.max(sum, maxsum);
        }
        return maxsum;
    }
}
```





## [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

 

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

 

**提示：**

- `1 <= intervals.length <= 104`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 104`

解题步骤

```
class Solution {
    public int[][] merge(int[][] intervals) {
```

这段代码定义了一个名为 `Solution` 的类，其中包含一个名为 `merge` 的方法，接受一个二维整数数组 `intervals` 作为参数，并返回一个二维整数数组。

```
javaCopy code
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
```

这一行对二维数组 `intervals` 进行排序，按照每个子数组的第一个元素进行升序排序。这里使用了 `Arrays.sort()` 方法，以及一个 lambda 表达式 `(a, b) -> a[0] - b[0]` 来指定排序的方式。

```
javaCopy code
        List<int[]> merged = new ArrayList<>();
```

在这里，创建了一个 `ArrayList` 对象 `merged`，用于存储合并后的区间。

```
javaCopy code
        for (int i = 0; i < intervals.length;) {
```

这是一个循环，用于遍历输入的区间数组 `intervals`。

```
javaCopy code            int end = intervals[i][1];
            int j = i + 1;
```

这两行代码初始化了两个变量 `end` 和 `j`。`end` 用于记录当前区间的结束值，而 `j` 用于标记下一个需要比较的区间。

```
javaCopy code            while (j < intervals.length && intervals[j][0] <= end) {
                end = Math.max(end, intervals[j][1]);
                j++;
            }
```

这是一个内部循环，用于找到可以合并的区间段。我们从当前区间的结束值开始，然后不断向后遍历，直到找到下一个与当前区间相交的区间段为止。在这个过程中，我们不断更新合并后的区间段的结束值 `end`，以确保合并后的区间覆盖了所有相交的区间。

```
javaCopy code
            merged.add(new int[]{intervals[i][0], end});
```

找到了合并后的区间段之后，我们将其起始值和结束值添加到结果列表 `merged` 中，形成一个新的数组，然后将这个数组添加到列表中。

```
javaCopy code            i = j;
        }
```

最后，我们将遍历索引 `i` 更新为下一个未合并的区间段的起始位置，以继续下一轮的合并。

```
javaCopy code        return merged.toArray(new int[merged.size()][]);
    }
}
```

最后，我们将列表 `merged` 转换为二维数组，并将其作为方法的返回值返回。

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 对区间数组按照起始值进行升序排序
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        
        // 创建一个列表用于存储合并后的区间
        List<int[]> merged = new ArrayList<>();						
        
        // 遍历区间数组
        for (int i = 0; i < intervals.length;) {						//这里不应该i++
            // 记录当前区间的结束值
            int end = intervals[i][1];									//end = intervals[i][1];而不是[i][0]
            // 初始化下一个待比较区间的索引
            int j = i + 1;
            
            // 找到所有与当前区间相交的区间，并将它们合并为一个区间
            while (j < intervals.length && intervals[j][0] <= end) {  //这里没写等于,而且应该是当前数组结束值跟intervals[j][0]开始值比较
                end = Math.max(end, intervals[j][1]);					
                j++;
            }
            // 将合并后的区间添加到列表中
            merged.add(new int[]{intervals[i][0], end});
            
            // 更新遍历索引，跳过已合并的区间
            i = j;
        }
        
        // 将列表转换为二维数组并返回
        return merged.toArray(new int[merged.size()][]);					//返回是size()
    }
}
```

## [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

 

**示例 1:**

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

**示例 2:**

```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

 

**提示：**

- `1 <= nums.length <= 105`

- `-231 <= nums[i] <= 231 - 1`

- `0 <= k <= 105`

  1.解题思路
      先写一个翻转数组的方法，再使用主方法反转3次
      操作	结果
  原始数组	  1 2 3 4 5 6 7
  翻转所有元素   7 6 5 4 3 2 1
  翻转前四位元素 5 6 7， 4 3 2 1
  翻转后三位元素 5 6 7 ，1 2 3 4
  
  直接写
  
  ```java
  class Solution {
      public void rotate(int[] nums, int k) {
          int n = nums.length;
          k %= n; // 处理 k 大于数组长度的情况
          
          reverse(nums, 0, n - 1); // 反转整个数组
          reverse(nums, 0, k - 1); // 反转前 k 个元素
          reverse(nums, k, n - 1); // 反转剩余的元素
      }
      
      // 反转数组指定范围内的元素
      private void reverse(int[] nums, int start, int end) {
          while (start < end) {
              int temp = nums[start];
              nums[start] = nums[end];
              nums[end] = temp;
              start++;
              end--;
          }
      }
  }
  ```
  
  
  
## [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

  给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。

  题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

  请 **不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。

   

  **示例 1:**

  ```
  输入: nums = [1,2,3,4]
  输出: [24,12,8,6]
  ```

  **示例 2:**

  ```
  输入: nums = [-1,1,0,-3,3]
  输出: [0,0,9,0,0]
  ```

   

  **提示：**

  - `2 <= nums.length <= 105`
  
  - `-30 <= nums[i] <= 30`
  
  - **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内
  
    
    
    1.解题思路
    
    创建两个数组分别当前遍历数字左边的乘积或者右边的乘积
    
    最后遍历一遍nums，把两个数组乘积相乘就可以得到除这个i元素，其他乘积之和
    
    ![3609e17af092e17ee972f644e8f850d4](C:\Users\seek-\AppData\Roaming\Tencent\QQ\Temp\3609e17af092e17ee972f644e8f850d4.jpg)
    
    ```java
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        
        // 用于存储左侧所有元素的乘积
        int[] leftProducts = new int[n];
        leftProducts[0] = 1;
        for (int i = 1; i < n; i++) {
            leftProducts[i] = leftProducts[i - 1] * nums[i - 1];
        }
        
        // 用于存储右侧所有元素的乘积
        int[] rightProducts = new int[n];
        rightProducts[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            rightProducts[i] = rightProducts[i + 1] * nums[i + 1];
        }
        
        // 将左侧和右侧的乘积相乘得到最终结果
        int[] answer = new int[n];
        for (int i = 0; i < n; i++) {
            answer[i] = leftProducts[i] * rightProducts[i];
        }
        
        return answer;
    }
    ```
    

# 六，矩阵

## [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

    给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**


​     
​    
​    **示例 1：**
​    
​    ![img](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)
​    
​    ```
​    输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
​    输出：[[1,0,1],[0,0,0],[1,0,1]]
​    ```
​    
​    **示例 2：**
​    
​    ![img](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)
​    
​    ```
​    输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
​    输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
​    ```


​     
​    
​    **提示：**
​    
​    - `m == matrix.length`
​    - `n == matrix[0].length`
​    - `1 <= m, n <= 200`
​    - `-231 <= matrix[i][j] <= 231 - 1`

1.解题思路，创建两个数组，长度分别为nums数组的行数和列数

记录每一行和每一列的0所对应的位置，再创建一个循环，如果两个数组当前值为true

就把当前数记录为0

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length; // 获取矩阵的行数
        int n = matrix[0].length; // 获取矩阵的列数
        
        // 用于记录哪些行和列需要置零的布尔数组
        boolean[] row = new boolean[m];
        boolean[] col = new boolean[n];
        
        // 找出矩阵中值为零的位置，并标记相应的行和列
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    row[i] = true; // 标记包含零的行
                    col[j] = true; // 标记包含零的列
                }
            }
        }
        
        // 再次遍历矩阵，并将标记为零的行和列置零
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (row[i] || col[j]) { // 如果行或列包含零
                    matrix[i][j] = 0; // 将元素置零
                }
            }
        }
    }
}
```



## [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

 

**提示：**

- `m == matrix.length`

- `n == matrix[i].length`

- `1 <= m, n <= 10`

- `-100 <= matrix[i][j] <= 100`

  

1。解题思路

规定一个边界，每次遍历当前行，更新边界

```java
import java.util.ArrayList;
import java.util.List;

public class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> ans = new ArrayList<>(); // 用于存储遍历结果的列表
        
        // 如果矩阵为空，直接返回空列表
        if (matrix.length == 0 || matrix[0].length == 0)
            return ans;

        int lineBegin = 0, lineEnd = matrix[0].length - 1; // 记录行的起始和结束位置
        int listBegin = 0, listEnd = matrix.length - 1; // 记录列的起始和结束位置

        // 循环遍历直到矩阵全部遍历完毕
        while (true) {
            // 从左往右遍历当前行				
            //由于length-1所以for条件要大于等于，小于等于
            for (int i = lineBegin; i <= lineEnd; i++)
                ans.add(matrix[listBegin][i]);
            // 移动到下一行
            if (++listBegin > listEnd)
                break;

            // 从上往下遍历当前列
            for (int i = listBegin; i <= listEnd; i++)
                ans.add(matrix[i][lineEnd]);
            // 移动到下一列
            if (--lineEnd < lineBegin)
                break;

            // 从右往左遍历当前行
            for (int i = lineEnd; i >= lineBegin; i--)
                ans.add(matrix[listEnd][i]);
            // 移动到上一行
            if (--listEnd < listBegin)			//小于写成大于了
                break;

            // 从下往上遍历当前列
            for (int i = listEnd; i >= listBegin; i--)	//list写成ling了
                ans.add(matrix[i][lineBegin]);
            // 移动到下一列
            if (++lineBegin > lineEnd)			
                break;
        }
        return ans; // 返回遍历结果
    }
}
```

## [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)

```
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

 

**提示：**

- `n == matrix.length == matrix[i].length`

- `1 <= n <= 20`

- `-1000 <= matrix[i][j] <= 1000`

  ```java
  class Solution {
      public void rotate(int[][] matrix) {
          if(matrix.length==0||matrix[0].length==0){
  			return;
          }
  		int n = matrix[0].length;
          int m =	matrix.length;
          int[][] max = new int[n][m];
          //按照每一列依次导入另一个数组
          //从最后一行开始，到第一行
          //for循环每一列
          //导入，741,852,963
          for(int i =0;i<n;i++){
              int x= 0;
              for(int k =m-1;k>=0;k--){
  				max[i][x] = matrix[k][i];
                  x++;
              }
          }
          //再讲代码依次导出
          for(int i =0;i<n;i++){
              for(int k =0;k<m;k++){
  				matrix[i][k]=max[i][k];
              }
              
          }
      }
  }
  ```

## [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

  

编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

 

**提示：**

- `m == matrix.length`

- `n == matrix[i].length`

- `1 <= n, m <= 300`

- `-109 <= matrix[i][j] <= 109`

- 每行的所有元素从左到右升序排列

- 每列的所有元素从上到下升序排列

- `-109 <= target <= 109`

  1，解题思路，先判断

  这个数在不在这一行数字中

  这一行第一个数 <= target <= 这一行最后一个数

  如果在，就逐一对比

  ```java
  class Solution {
      public boolean searchMatrix(int[][] matrix, int target) {
          if(matrix.length==0||matrix[0].length==0){
                  return false;
          }
          int n = matrix.length;
          int m = matrix[0].length;
          for(int i = 0;i<n;i++){
              if(matrix[i][0]<=target && target<=matrix[i][m-1]){
              for(int k=0;k<m;k++){
                  if(matrix[i][k]==target)
                  return true;
             					 }
              }
          }
          return false;
      }
  }
  ```




# 七，链表

## [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**自定义评测：**

**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：

- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
- `listA` - 第一个链表
- `listB` - 第二个链表
- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

 

**示例 1：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

 

**示例 2：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

 

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `1 <= m, n <= 3 * 104`
- `1 <= Node.val <= 105`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`

 

**进阶：**你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？

解题思路；
一图胜千言，看图你就明白了

空间复杂度 O(1)O(1)O(1) 时间复杂度为 O(n)O(n)O(n)

这里使用图解的方式，解释比较巧妙的一种实现。

根据题目意思
如果两个链表相交，那么相交点之后的长度是相同的

我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。
为此，我们必须消除两个链表的长度差

指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历
如果 pA 到了末尾，则 pA = headB 继续遍历
如果 pB 到了末尾，则 pB = headA 继续遍历
比较长的链表指针指向较短链表head时，长度差就消除了
如此，只需要将最短链表遍历两次即可找到位置
听着可能有点绕，看图最直观，链表的题目最适合看图了


![相交链表.png](https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png)

代码也很简单

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

public class Solution {
    /**
     * 寻找两个单链表的交点
     * 
     * @param headA 第一个链表的头结点
     * @param headB 第二个链表的头结点
     * @return 两个链表的交点，如果不存在交点则返回 null
     */
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 检查链表是否为空
        if (headA == null || headB == null)
            return null;
        
        // 初始化两个指针 pA 和 pB
        ListNode pA = headA, pB = headB;
        
        // 循环遍历链表，直到找到交点或遍历结束
        while (pA != pB) {
            // 如果 pA 到达链表尾部，则将 pA 指向 headB，否则指向下一个节点
            pA = (pA == null) ? headB : pA.next;						//pa三元运算符写headB而不是headA
            	
            // 如果 pB 到达链表尾部，则将 pB 指向 headA，否则指向下一个节点
            pB = (pB == null) ? headA : pB.next;						//pa三元运算符写headA而不是headB
        }
        
        // 返回交点或 null
        return pA;
    }
}
```

## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**

```
输入：head = []
输出：[]
```

 

**提示：**

- 链表中节点的数目范围是 `[0, 5000]`
- `-5000 <= Node.val <= 5000`

 

**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？



解题思路：

如下图所示，题目要求将链表反转。本文介绍迭代（双指针）、递归两种实现方法。

![Picture1.png](https://pic.leetcode-cn.com/1604779288-WXygqL-Picture1.png)

方法一：迭代（双指针）
考虑遍历链表，并在访问各节点时修改 next 引用指向，算法流程见注释。

解题思路：

如下图所示，题目要求将链表反转。本文介绍迭代（双指针）、递归两种实现方法。

![Picture1.png](https://pic.leetcode-cn.com/1604779288-WXygqL-Picture1.png)

方法一：迭代（双指针）

考虑遍历链表，并在访问各节点时修改 `next` 引用指向，算法流程见注释。

![img](https://pic.leetcode-cn.com/1604779288-fMPcDn-Picture2.png)

1 / 12

![img](https://pic.leetcode-cn.com/1604779288-jExDGV-Picture3.png)

2 / 12

![img](https://pic.leetcode-cn.com/1604779444-fENrGT-Picture4.png)

3 / 12

![img](https://pic.leetcode-cn.com/1604779288-GaydTj-Picture5.png)

4 / 12

![img](https://pic.leetcode-cn.com/1604779288-gowIkz-Picture6.png)

5 / 12

![img](https://pic.leetcode-cn.com/1604779288-OLQNEW-Picture11.png)

10 / 12

![img](https://pic.leetcode-cn.com/1604779288-MHParU-Picture12.png)

11 / 12

![img](https://pic.leetcode-cn.com/1604779288-CaAUfb-Picture13.png)

12/ 12

代码如下

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head, pre = null;
        while(cur != null) {
            ListNode tmp = cur.next; // 暂存后继节点 cur.next
            cur.next = pre;          // 修改 next 引用指向
            pre = cur;               // pre 暂存 cur
            cur = tmp;               // cur 访问下一节点
        }
        return pre;
    }
}
```



## [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

给你一个单链表的头节点 `head` ，请你判断该链表是否为

回文链表

。如果是，返回 `true` ；否则，返回 `false` 。



 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)

```
输入：head = [1,2]
输出：false
```

 

**提示：**

- 链表中节点数目在范围`[1, 105]` 内
- `0 <= Node.val <= 9`

 

**进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    // 判断给定的单链表是否是回文的
    public boolean isPalindrome(ListNode head) {
        // 创建一个 ArrayList 对象，用于存储链表节点的值
        List<Integer> list = new ArrayList<>();
        // 定义指针 pa 指向链表头节点
        ListNode pa = head;
        // 遍历链表，将节点的值逐个添加到数组中
        while (pa != null) {
            list.add(pa.val);
            pa = pa.next; // 将 pa 指向下一个节点				  //这里是pa.next而不是head.next
        }
        // 初始化双指针
        int begin = 0;
        int end = list.size() - 1;
        // 使用双指针判断是否回文
        while (begin < end) {
            // 如果两个指针指向的元素值不相等，则链表不是回文的，返回 false
            if (!list.get(begin).equals(list.get(end)))			 //这里是equals，并不是==，==是判断地址是否相等
                return false;
            // 移动指针
            begin++;
            end--;
        }
        // 如果循环结束后两个指针相遇，则链表是回文的，返回 true
        return true;
    }
}
```

## [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

 

**提示：**

- 链表中节点的数目范围是 `[0, 104]`
- `-105 <= Node.val <= 105`
- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。

 

**进阶：**你能用 `O(1)`（即，常量）内存解决此问题吗？

1.解题思路

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

```java
import java.util.HashSet;

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    // 判断链表中是否存在环
    public boolean hasCycle(ListNode head) {
        // 如果链表为空或者只有一个节点，则肯定不存在环
        if (head == null || head.next == null)
            return false;
        
        // 创建一个 HashSet 用于存储访问过的节点
        HashSet<ListNode> set = new HashSet<>();
        
        // 从头节点开始遍历链表
        ListNode node = head;
        set.add(node);
        while (true) {
            // 移动到下一个节点
            node = node.next;
            
            // 如果到达链表末尾，则说明不存在环
            if (node == null)
                return false;
            
            // 如果集合中已经包含了当前节点，则说明存在环
            if (set.contains(node))								//重要的是HashSet的contains方法，一定要记住，是检查是否有这个元素的
                return true;
            
            // 否则将当前节点添加到集合中
            set.add(node);
        }
    }
}
```

.方法二：快慢指针
思路及算法

本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。

假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。

我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

![img](https://assets.leetcode-cn.com/solution-static/141/1.png)

为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？

观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。

当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。

```java
public class Solution {
    // 判断链表中是否存在环
    public boolean hasCycle(ListNode head) {
        // 如果链表为空或只有一个节点，则肯定不存在环
        if (head == null || head.next == null) {
            return false;
        }
        
        // 使用双指针，分别指向链表的头节点和头节点的下一个节点
        ListNode slow = head; // 慢指针，每次移动一步
        ListNode fast = head.next; // 快指针，每次移动两步
        
        // 当快指针和慢指针相遇时，说明链表中存在环
        while (slow != fast) {
            // 如果快指针到达了链表的末尾，则说明不存在环
            if (fast == null || fast.next == null) {
                return false;
            }
            // 慢指针移动一步
            slow = slow.next;
            // 快指针移动两步
            fast = fast.next.next;
        }
        
        // 当循环结束时，说明快指针和慢指针相遇，存在环
        return true;
    }
}
```

## [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

 

**提示：**

- 链表中节点的数目范围在范围 `[0, 104]` 内
- `-105 <= Node.val <= 105`
- `pos` 的值为 `-1` 或者链表中的一个有效索引

 

**进阶：**你是否可以使用 `O(1)` 空间解决此题？

1.跟141题方法一思路一样，只是返回的是 ListNode 或者 null

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
         // 如果链表为空或者只有一个节点，则肯定不存在环
        if (head == null || head.next == null)
            return null;										//这里变成return null;
        
        // 创建一个 HashSet 用于存储访问过的节点
        HashSet<ListNode> set = new HashSet<>();
        
        // 从头节点开始遍历链表
        ListNode node = head;
        set.add(node);
        while (true) {
            // 移动到下一个节点
            node = node.next;
            
            // 如果到达链表末尾，则说明不存在环
            if (node == null)
                return null;									//这里变成return null;
            
            // 如果集合中已经包含了当前节点，则说明存在环
            if (set.contains(node))								//重要的是HashSet的contains方法，一定要记住，是检查是否有这个元素的
                return node;									//这里变成return node;
            
            // 否则将当前节点添加到集合中
            set.add(node);
        }
    }
}
```

## [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```

 

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`

- `-100 <= Node.val <= 100`

- `l1` 和 `l2` 均按 **非递减顺序** 排列

  1解题思路

  比较2个节点的数值大小看连接哪个节点

  ```java
  /**
   * Definition for singly-linked list.
   * public class ListNode {
   *     int val;
   *     ListNode next;
   *     ListNode() {}
   *     ListNode(int val) { this.val = val; }
   *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
   * }
   */
  class Solution {
      // 合并两个有序链表
      public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
          // 如果其中一个链表为空，直接返回另一个链表
          if (list1 == null) return list2;
          if (list2 == null) return list1;
          
          // 创建指针 merge 用于存储合并后的链表头节点
          ListNode merge;
          // 比较两个链表头节点的值，选择较小的作为合并后的头节点
          if (list1.val < list2.val) {
              merge = list1;
              list1 = list1.next;
          } else {
              merge = list2;
              list2 = list2.next;
          }
          
          // 创建指针 m 指向合并后的链表头节点
          ListNode m = merge;
          
          // 循环合并两个链表
          while (true) {
              // 如果其中一个链表为空，将另一个链表直接接在合并后的链表末尾
              if (list1 == null) {
                  merge.next = list2;
                  break;
              }
              if (list2 == null) {
                  merge.next = list1;
                  break;
              }
              // 比较两个链表当前节点的值，选择较小的节点接入合并后的链表
              if (list1.val < list2.val) {
                  merge.next = list1;
                  list1 = list1.next;
              } else {
                  merge.next = list2;
                  list2 = list2.next;
              }
              // 更新 merge 指针指向新的末尾节点
              merge = merge.next;
          }
          
          // 返回合并后的链表头节点
          return m;
      }
  }
  ```

  

方法二：迭代
思路

我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。

算法

首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。

在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。

下图展示了 1->4->5 和 1->2->3->6 两个链表迭代合并的过程

![img](https://assets.leetcode-cn.com/solution-static/21/35.PNG)

```java
class Solution {
    // 合并两个有序链表
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 创建一个哑节点作为新链表的头节点
        ListNode prehead = new ListNode(-1);

        // 创建指针 prev 指向新链表的尾节点
        ListNode prev = prehead;

        // 循环直到其中一个链表为空
        while (l1 != null && l2 != null) {
            // 比较两个链表当前节点的值，将较小的节点接入新链表
            if (l1.val <= l2.val) {
                prev.next = l1;
                l1 = l1.next;
            } else {
                prev.next = l2;
                l2 = l2.next;
            }
            // 更新指针 prev 指向新链表的尾节点
            prev = prev.next;
        }

        // 合并后 l1 和 l2 最多只有一个还未被合并完，将链表末尾指向未合并完的链表即可
        prev.next = l1 == null ? l2 : l1;

        // 返回合并后的链表头节点
        return prehead.next;
    }
}
```

时间复杂度：O(n+m)O(n + m)O(n+m)，其中 nnn 和 mmm 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)O(n+m)O(n+m)。

空间复杂度：O(1)O(1)O(1)。我们只需要常数的空间存放若干变量。

## [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

1。解题思路

标签：链表
将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 000，比如 987 + 23 = 987 + 023 = 1010
每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值
如果两个链表全部遍历完毕后，进位值为 111，则在新链表最前方添加节点 111
小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点 head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。

![img](https://pic.leetcode-cn.com/400f2a615319c4f0f42c39eb8b8902984922d1e778ca461569ff64460eaa9757-file_1559748028117)






```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        //定义一个新联表伪指针，用来指向头指针，返回结果
        ListNode prev = new ListNode(0);
         //定义一个可移动的指针，用来指向存储两个数之和的位置
        ListNode cur = prev;
        //定义一个进位数的指针，用来存储当两数之和大于10的时候，
        int carry = 0;
        //当l1 不等于null或l2 不等于空时，就进入循环
        while(l1!=null || l2!=null){
            //如果l1 不等于null时，就取他的值，等于null时，就赋值0，保持两个链表具有相同的位数
            int x= l1 !=null ? l1.val : 0;
             //如果l1 不等于null时，就取他的值，等于null时，就赋值0，保持两个链表具有相同的位数
            int y = l2 !=null ? l2.val : 0;
            //将两个链表的值，进行相加，并加上进位数
            int sum = x + y + carry;
            //计算进位数
            carry = sum / 10;
            //计算两个数的和，此时排除超过10的请况（大于10，取余数）
            sum = sum % 10;													//是 sum = sum % 10;
            //将求和数赋值给新链表的节点，
            //注意这个时候不能直接将sum赋值给cur.next = sum。这时候会报，类型不匹配。
            //所以这个时候要创一个新的节点，将值赋予节点
            cur.next = new ListNode(sum);										//记得是next
            //将新链表的节点后移
            cur = cur.next;
            //当链表l1不等于null的时候，将l1 的节点后移
            if(l1 !=null){
                l1 = l1.next;
            }
            //当链表l2 不等于null的时候，将l2的节点后移
            if(l2 !=null){
                l2 = l2.next;
            } 
        }
        //如果最后两个数，相加的时候有进位数的时候，就将进位数，赋予链表的新节点。
        //两数相加最多小于20，所以的的值最大只能时1
        if(carry == 1){
            cur.next = new ListNode(carry);									//记得是next，并且不用再把指针后移
        }
        //返回链表的头节点
        return prev.next;												//记得返回next
    }
}
```



## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```

 

**提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

 

**进阶：**你能尝试使用一趟扫描实现吗？

方法一：计算链表长度
思路与算法

一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 LLL。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L−n+1L-n+1L−n+1 个节点时，它就是我们需要删除的节点。

为了与题目中的 nnn 保持一致，节点的编号从 111 开始，头节点为编号 111 的节点。

为了方便删除操作，我们可以从哑节点开始遍历 L−n+1L-n+1L−n+1 个节点。当遍历到第 L−n+1L-n+1L−n+1 个节点时，它的下一个节点就是我们需要删除的节点，这样我们只需要修改一次指针，就能完成删除操作。

![p1](https://assets.leetcode-cn.com/solution-static/19/p1.png)

代码如下

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 如果链表为空，直接返回
        if(head == null)
            return head;
        
        // 创建一个新的节点，作为头节点的前驱节点
        ListNode dummy = new ListNode(0, head);
        
        // 定义两个指针，初始指向头节点
        ListNode first = dummy;
        ListNode second = head;
        
        // 遍历链表，让第一个指针先移动 n+1 步
        for(int i = 0; i < n + 1; i++) {
            first = first.next;
        }
        
        // 然后同时移动两个指针，直到第一个指针到达链表末尾
        while(first != null) {
            first = first.next;
            second = second.next;
        }
        
        // 此时第二个指针指向待删除节点的前一个节点
        // 删除第二个指针指向的节点
        second.next = second.next.next;
        
        // 返回头节点
        return dummy.next;
    }
}
```

## [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内

- `0 <= Node.val <= 100`

  迭代实现
  迭代实现就比 stack 方式复杂多了，需要很小心的处理节点的指向。
  这里我们需要三个指针，a，b，tmp。
  假设链表是
  1->2->3->4->5->6
  在迭代的时候，每次处理两个节点，于是第一轮 a 指向 1，b 指向 2。
  第二轮的时候 a 指向 3，b 指向 4。第三轮的时候 a 指向 5，b 指向 6。
  我们通过 a.next = b.next，以及b.next=a就把两个指针的位置反转了，于是1->2就变成2->1。
  但这里有一个细节需要处理，当我们第二轮迭代的时候，a 指向 3，b 指向 4。按照题目要求，最终应该是2->1->4->3。
  也就是节点 1 需要跟节点 4 串起来，只有两个指针就没法弄了，所以需要第三个指针 tmp，用来记录上一轮 a 的位置，然后下一轮迭代的时候，将原先的 a(也就是节点 1)指向 4。

  ![迭代.gif](https://pic.leetcode-cn.com/42c91b69e3f38d63a0d0153c440724e69bd2d24b95091b4dcc5c68172f8f4e1e-%E8%BF%AD%E4%BB%A3.gif)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        // 如果链表为空或者只有一个节点，直接返回头节点
        if(head == null || head.next == null)
            return head;
        
        // 创建一个新的虚拟头节点作为新链表的起始点
        ListNode dummy = new ListNode(0, head.next);
        // 定义三个指针，分别表示当前节点的前一个节点、当前节点、当前节点的下一个节点
        ListNode left = dummy;  // 前一个节点
        ListNode now = head;    // 当前节点
        ListNode right = head.next; // 下一个节点
        
        // 循环遍历链表，每次处理两个节点
        while(now != null && now.next != null){
            // 交换当前节点和下一个节点
            left.next = right;
            now.next = right.next;
            right.next = now;
            
            // 移动指针，准备下一次交换
            left = now;
            now = now.next;
            if(now != null)
                right = now.next;
        }
        
        // 返回交换后的链表的起始节点
        return dummy.next;
    }
}
```

## [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)**

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

 

**提示：**

- `0 <= n <= 1000`
- `-104 <= Node.val <= 104`
- `Node.random` 为 `null` 或指向链表中的节点。

 1.使用hash表来两两对应node和新创node节点之间的关系，

第一遍遍历，复制val值并新建node

第二遍遍历，复制next值和random值

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
public Node copyRandomList(Node head) {
        if (head == null) return null;

        // 创建哈希表，用于存储原始节点和复制节点之间的映射关系
        Map<Node, Node> map = new HashMap<>();
        
        // 第一遍遍历：复制节点，并建立原始节点和复制节点之间的映射关系
        Node curr = head;
        while (curr != null) {
            map.put(curr, new Node(curr.val));
            curr = curr.next;
        }
        
        // 第二遍遍历：连接复制节点的 next 和 random 指针
        curr = head;
        while (curr != null) {
            map.get(curr).next = map.get(curr.next);
            map.get(curr).random = map.get(curr.random);
            curr = curr.next;
        }
        
        // 返回复制链表的头节点
        return map.get(head);
    }
}
```

## [148. 排序链表](https://leetcode.cn/problems/sort-list/)

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)

```
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
```

**示例 3：**

```
输入：head = []
输出：[]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 5 * 104]` 内
- `-105 <= Node.val <= 105`

 

**进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

1.解题思路

把数组中的val值，导入到list中，在对数组进行排序，重新创建ListNode节点，挨个新建并输入val值

注意使用 Collections.sort(nums);记住这个接口名，对数组排序是Arrays.sort();

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        // 创建一个列表，用于存储链表节点的值
        List<Integer> nums = new ArrayList<>();
        
        // 将链表节点的值添加到列表中
        while (head != null) {
            nums.add(head.val);
            head = head.next; 
        }
        
        // 对列表中的值进行排序
        Collections.sort(nums);
        
        // 创建一个新的链表头节点
        ListNode node = new ListNode();
        ListNode begin = node; 
        
        // 根据排序后的列表重新构建链表
        for (Integer num : nums) {
            node.next = new ListNode(num);
            node = node.next;
        }
        
        // 返回排序后的链表头节点
        return begin.next;
    }
}
```

## [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

 

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

 

**提示：**

- `1 <= capacity <= 3000`

- `0 <= key <= 10000`

- `0 <= value <= 105`

- 最多调用 `2 * 105` 次 `get` 和 `put`

  

  【图解】一张图秒懂 LRU！

  ![img](https://pic.leetcode.cn/1696039105-PSyHej-146-3-c.png)

  答疑
  问：需要几个哨兵节点？

  答：一个就够了。一开始哨兵节点 dummy\textit{dummy}dummy 的 prev\textit{prev}prev 和 next\textit{next}next 都指向 dummy\textit{dummy}dummy。随着节点的插入，dummy\textit{dummy}dummy 的 next\textit{next}next 指向链表的第一个节点（最上面的书），prev\textit{prev}prev 指向链表的最后一个节点（最下面的书）。

  问：为什么节点要把 key\textit{key}key 也存下来？

  答：在删除链表末尾节点时，也要删除哈希表中的记录，这需要知道末尾节点的 key\textit{key}key。

  代码如下

  ```java
  import java.util.HashMap;
  import java.util.Map;
  
  public class LRUCache {
      // 节点类，用于构建双向链表
      private static class Node {
          int key, value;
          Node prev, next;
  
          Node(int k, int v) {
              key = k;
              value = v;
          }
      }
  
      private final int capacity; // 缓存容量
      private final Node dummy = new Node(0, 0); // 哨兵节点，简化边界处理
      private final Map<Integer, Node> keyToNode = new HashMap<>(); // 哈希表，存储键值对
  
      // 构造函数，初始化 LRUCache
      public LRUCache(int capacity) {
          this.capacity = capacity;
          // 初始化哨兵节点，构建循环双向链表
          dummy.prev = dummy;
          dummy.next = dummy;
      }
  
      // 获取指定 key 对应的 value 值
      public int get(int key) {
          Node node = getNode(key);
          return node != null ? node.value : -1; // 如果节点存在，则返回节点的值，否则返回 -1
      }
  
      // 向 LRUCache 中添加或更新键值对
      public void put(int key, int value) {
          Node node = getNode(key); // 获取指定 key 对应的节点
          if (node != null) { // 如果节点存在，则更新节点的值
              node.value = value;
              return;
          }
          node = new Node(key, value); // 如果节点不存在，则创建新节点
          keyToNode.put(key, node); // 将新节点加入哈希表中
          pushFront(node); // 将新节点添加到链表头部
          if (keyToNode.size() > capacity) { // 如果 LRUCache 容量超过限制
              Node backNode = dummy.prev; // 获取链表尾部节点（最近最少使用节点）
              keyToNode.remove(backNode.key); // 从哈希表中移除对应的键值对
              remove(backNode); // 从链表中移除尾部节点
          }
      }
  
      // 根据 key 获取节点
      private Node getNode(int key) {
          if (!keyToNode.containsKey(key)) { // 如果哈希表中不包含指定 key
              return null; // 返回空，表示未找到节点
          }
          Node node = keyToNode.get(key); // 从哈希表中获取指定 key 对应的节点
          remove(node); // 移除原节点
          pushFront(node); // 将节点移动到链表头部，表示最近被访问
          return node; // 返回节点
      }
  
      // 从双向链表中移除指定节点
      private void remove(Node x) {
          x.prev.next = x.next; // 将 x 的前驱节点指向 x 的后继节点
          x.next.prev = x.prev; // 将 x 的后继节点指向 x 的前驱节点
      }
  
      // 将节点添加到双向链表的头部
      private void pushFront(Node x) {
          x.prev = dummy; // 将 x 的前驱节点指向哨兵节点
          x.next = dummy.next; // 将 x 的后继节点指向原头节点
          x.prev.next = x; // 将哨兵节点的后继节点指向 x
          x.next.prev = x; // 将原头节点的前驱节点指向 x
      }
  }
  ```

  ## [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

  给定一个二叉树 `root` ，返回其最大深度。

  二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

   

  **示例 1：**

  ![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

   

  ```
  输入：root = [3,9,20,null,null,15,7]
  输出：3
  ```

  **示例 2：**

  ```
  输入：root = [1,null,2]
  输出：2
  ```

   

  **提示：**

  - 树中节点的数量在 `[0, 104]` 区间内。

  - `-100 <= Node.val <= 100`

    方法一：深度优先搜索
    思路与算法

    如果我们知道了左子树和右子树的最大深度 lll 和 rrr，那么该二叉树的最大深度即为

    max⁡(l,r)+1\max(l,r) + 1
    max(l,r)+1
    而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1)O(1)O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。

    ![img](https://assets.leetcode-cn.com/solution-static/104/7.png)

代码如下

```java
/**
 * 二叉树节点的定义。
 *//*
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}*/
class Solution {
    public int maxDepth(TreeNode root) {
        // 如果根节点为空，则深度为0。
        if(root == null)
            return 0;
        
        // 递归计算左子树的最大深度。
        int leftNum = maxDepth(root.left);
        
        // 递归计算右子树的最大深度。
        int rightNum = maxDepth(root.right);
        
        // 返回左右子树的最大深度加上当前节点的深度（1）。
        return Math.max(leftNum, rightNum) + 1;
    }
}
```



# 八，二叉树

## [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目范围在 `[0, 100]` 内

- `-100 <= Node.val <= 100`

  思路

  既然是翻转，不要想那么多，在遍历左子树时创建右子树，在遍历右子树时创建左子树就行。

  解题方法

  直接使用递归返回条件创建树再依次返回结果。

  ```java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode() {}
   *     TreeNode(int val) { this.val = val; }
   *     TreeNode(int val, TreeNode left, TreeNode right) {
   *         this.val = val;
   *         this.left = left;
   *         this.right = right;
   *     }
   * }
   */
  class Solution {
      public TreeNode invertTree(TreeNode root) {
              if(root==null)
              return null;   
              return new TreeNode(root.val,invertTree(root.right),invertTree(root.left));
      }
  }
  ```

  

## [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

 

**提示：**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

 

**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？

乍一看无从下手，但用递归其实很好解决。
根据题目的描述，镜像对称，就是左右两边相等，也就是左子树和右子树是相当的。
注意这句话，左子树和右子相等，也就是说要递归的比较左子树和右子树。
我们将根节点的左子树记做 left，右子树记做 right。比较 left 是否等于 right，不等的话直接返回就可以了。
如果相当，比较 left 的左节点和 right 的右节点，再比较 left 的右节点和 right 的左节点
比如看下面这两个子树(他们分别是根节点的左子树和右子树)，能观察到这么一个规律：
左子树 222 的左孩子 == 右子树 222 的右孩子
左子树 222 的右孩子 == 右子树 222 的左孩子

​     2             2
​    /   \          /   \
  3    4        4    3
 / \     / \     / \    / \
8  7 6  5  5  6  7  8
根据上面信息可以总结出递归函数的两个条件：
终止条件：

left 和 right 不等，或者 left 和 right 都为空
递归的比较 left，left 和 right.right，递归比较 left，right 和 right.left
动态图如下：

![2.gif](https://pic.leetcode-cn.com/2449af8862537df2cbbc45a07764415c1a10769677c822fa271ea7447c8fa128-2.gif)

算法的时间复杂度是 O(n)，因为要遍历 n个节点
空间复杂度是 O(n)，空间复杂度是递归的深度，也就是跟树高度有关，最坏情况下树变成一个链表结构，高度是n。
代码实现：

```java
class Solution {
    // 判断给定的二叉树是否对称
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true; // 空树是对称的
        }
        // 调用递归函数，比较左节点和右节点
        return dfs(root.left, root.right);
    }
    
    // 递归函数，判断两个节点是否对称
    boolean dfs(TreeNode left, TreeNode right) {
        // 递归的终止条件是两个节点都为空
        // 或者两个节点中有一个为空
        // 或者两个节点的值不相等
        if (left == null && right == null) {
            return true; // 左右节点都为空，对称
        }
        if (left == null || right == null) {
            return false; // 一个节点为空，一个节点不为空，不对称
        }
        if (left.val != right.val) {
            return false; // 左右节点值不相等，不对称
        }
        // 再递归的比较 左节点的左孩子 和 右节点的右孩子
        // 以及比较 左节点的右孩子 和 右节点的左孩子
        return dfs(left.left, right.right) && dfs(left.right, right.left);
    }
}
```

## [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

**示例 2：**

```
输入：root = [1,2]
输出：1
```

1.解题思路

使用递归遍历的话，经过根结点的路径并不一定是最大的，要考虑到每一个节点的左右子树最大长度相加的情况

要添加一个全局变量，实时记录对比，每一个节点的左右子树最大长度相加的数据

int maxDiameter = 0; // 用于记录最大直径

![image.png](https://pic.leetcode-cn.com/f6c78da419307c972303f9e55f18fc36c57cbc6c5f3f0a9a2a443740c555b056-image.png)

代码如下：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int maxDiameter = 0; // 用于记录最大直径
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null)
            return 0;
        calculateDepth(root);
        return maxDiameter;
    }
    // 计算树的深度，并更新最大直径
    private int calculateDepth(TreeNode root) {
        if (root == null)
            return 0;
        int leftDepth = calculateDepth(root.left); // 左子树深度
        int rightDepth = calculateDepth(root.right); // 右子树深度
        // 更新最大直径
        maxDiameter = Math.max(maxDiameter, leftDepth + rightDepth);
        // 返回以当前节点为根节点的子树的深度
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

## [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内

- `-1000 <= Node.val <= 1000`

  BFS 遍历使用**队列**数据结构：

  ```java
  void bfs(TreeNode root) {
      Queue<TreeNode> queue = new ArrayDeque<>();
      queue.add(root);
      while (!queue.isEmpty()) {
          TreeNode node = queue.poll(); // Java 的 pop 写作 poll()
          if (node.left != null) {
              queue.add(node.left);
          }
          if (node.right != null) {
              queue.add(node.right);
          }
      }
  }
  ```

  只是比较两段代码的话，最直观的感受就是：DFS 遍历的代码比 BFS 简洁太多了！这是因为递归的方式隐含地使用了系统的 栈，我们不需要自己维护一个数据结构。如果只是简单地将二叉树遍历一遍，那么 DFS 显然是更方便的选择。

  虽然 DFS 与 BFS 都是将二叉树的所有结点遍历了一遍，但它们遍历结点的顺序不同。


  ![DFS 与 BFS 对比](https://pic.leetcode-cn.com/fdcd3bd27f4008948084f6ec86b58535e71f66862bd89a34bd6fe4cc42d68e89.gif)

  这个遍历顺序也是 BFS 能够用来解「层序遍历」、「最短路径」问题的根本原因。下面，我们结合几道例题来讲讲 BFS 是如何求解层序遍历和最短路径问题的。

  BFS 的应用一：层序遍历
  BFS 的层序遍历应用就是本题了：

  LeetCode 102. Binary Tree Level Order Traversal 二叉树的层序遍历（Medium）

  给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。

  什么是层序遍历呢？简单来说，层序遍历就是把二叉树分层，然后每一层从左到右遍历：

  ![二叉树的层序遍历](https://pic.leetcode-cn.com/ce41cf1cabfa7a56387f63d927c8819fe1479ecf6f193a2a1b47964f5a8d1c8e.jpg)

  乍一看来，这个遍历顺序和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。然而，层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。

  ![BFS 遍历与层序遍历的输出结果不同](https://pic.leetcode-cn.com/fd1d63037d0e2f787d2140fee406e109094a4f66ab0837a7273f8b371eef8096.jpg)

  那么，怎么给 BFS 遍历的结果分层呢？我们首先来观察一下 BFS 遍历的过程中，结点进队列和出队列的过程：


  ![BFS 遍历的过程（动图）](https://pic.leetcode-cn.com/4529bf559c6a2d84d550eebaee027c3b7ae25069e4ec91f27b29a4c6358d6662.gif)

  截取 BFS 遍历过程中的某个时刻：

  ![BFS 遍历中某个时刻队列的状态](https://pic.leetcode-cn.com/9f178b56ff1c94388d893f2fb48e9e77e186aba7cfd7483637776359062d68b8.jpg)

  可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们 无法区分队列中的结点来自哪一层。

  因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。

  ```java
  // 二叉树的层序遍历
  void bfs(TreeNode root) {
      Queue<TreeNode> queue = new ArrayDeque<>();
      queue.add(root);
      while (!queue.isEmpty()) {
          int n = queue.size();
          for (int i = 0; i < n; i++) { 
              // 变量 i 无实际意义，只是为了循环 n 次
              TreeNode node = queue.poll();
              if (node.left != null) {
                  queue.add(node.left);
              }
              if (node.right != null) {
                  queue.add(node.right);
              }
          }
      }
  }
  ```

  这样，我们就将 BFS 遍历改造成了层序遍历。在遍历的过程中，结点进队列和出队列的过程为：

  ![img](https://pic.leetcode-cn.com/94cd1fa999df0276f1dae77a9cca83f4cabda9e2e0b8571cd9550a8ee3545f56.gif)

  可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。

  最终我们得到的题解代码为：

  ```java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode() {}
   *     TreeNode(int val) { this.val = val; }
   *     TreeNode(int val, TreeNode left, TreeNode right) {
   *         this.val = val;
   *         this.left = left;
   *         this.right = right;
   *     }
   * }
   */
  class Solution {
  public List<List<Integer>> levelOrder(TreeNode root) {
      List<List<Integer>> res = new ArrayList<>(); // 用于存储层序遍历结果的列表
  
      Queue<TreeNode> queue = new ArrayDeque<>(); // 创建一个队列，用于辅助层序遍历
      if (root != null) { // 如果根节点不为空，将根节点加入队列
          queue.add(root);
      }
      while (!queue.isEmpty()) { // 队列不为空时执行循环
          int n = queue.size(); // 获取当前层的节点个数
          List<Integer> level = new ArrayList<>(); // 创建一个列表，用于存储当前层的节点值
          for (int i = 0; i < n; i++) { // 遍历当前层的节点
              TreeNode node = queue.poll(); // 出队列，获取当前节点
              level.add(node.val); // 将当前节点值添加到当前层的列表中
              if (node.left != null) { // 如果当前节点有左子节点，将左子节点加入队列
                  queue.add(node.left);
              }
              if (node.right != null) { // 如果当前节点有右子节点，将右子节点加入队列
                  queue.add(node.right);
              }
          }
          res.add(level); // 将当前层的列表添加到结果列表中
      }
  
      return res; // 返回层序遍历结果
  }
  }
  ```

## [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

  给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 

  平衡

   二叉搜索树。

  

   

  **示例 1：**

  ![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

  ```
  输入：nums = [-10,-3,0,5,9]
  输出：[0,-3,9,-10,null,5]
  解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
  ```

  **示例 2：**

  ![img](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

  ```
  输入：nums = [1,3]
  输出：[3,1]
  解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
  ```

   

  **提示：**

  - `1 <= nums.length <= 104`

  - `-104 <= nums[i] <= 104`

  - `nums` 按 **严格递增** 顺序排列

    

方法一：中序遍历，总是选择中间位置左边的数字作为根节点
选择中间位置左边的数字作为根节点，则根节点的下标为 mid=(left+right)/2\textit{mid}=(\textit{left}+\textit{right})/2mid=(left+right)/2，此处的除法为整数除法。

![fig4](https://assets.leetcode-cn.com/solution-static/108/108_fig4.png)

代码如下:

```java
class Solution {
    // 将有序数组转换为平衡二叉搜索树
    public TreeNode sortedArrayToBST(int[] nums) {
        // 调用递归方法，传入数组和数组范围的起始和结束索引
        return sort(nums, 0, nums.length - 1);
    }
    
    // 递归方法：将有序数组的一段范围转换为平衡二叉搜索树
    public TreeNode sort(int[] nums, int left, int right) {
        // 如果左边界大于右边界，返回 null，表示没有节点
        if (left > right)
            return null;
        
        // 计算当前范围的中间索引
        int mid = (left + right) / 2;
        
        // 创建根节点，值为当前中间索引对应的元素
        TreeNode root = new TreeNode(nums[mid]);
        
        // 递归构建左子树：左边界到中间索引的左侧
        root.left = sort(nums, left, mid - 1);
        
        // 递归构建右子树：中间索引的右侧到右边界
        root.right = sort(nums, mid + 1, right);
        
        // 返回当前根节点
        return root;
    }
}
```

## [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左

  子树

  只包含

   小于 

  当前节点的数。

- 节点的右子树只包含 **大于** 当前节点的数。

- 所有左子树和右子树自身必须也是二叉搜索树。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

 

**提示：**

- 树中节点数目范围在`[1, 104]` 内

- `-231 <= Node.val <= 231 - 1`

  方法一：前序遍历

  ```java
  class Solution {
      // 主方法，判断给定的二叉树是否为二叉搜索树
      public boolean isValidBST(TreeNode root) {
          // 调用重载方法，传入根节点以及最小值和最大值的范围
          return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
      } 
      // 重载方法，递归地判断二叉树是否为二叉搜索树
      private boolean isValidBST(TreeNode node, long left, long right) {
          // 如果当前节点为空，返回 true，因为空树也算是二叉搜索树
          if (node == null)
              return true;
          // 获取当前节点的值
          long x = node.val;
          // 判断当前节点的值是否在合法范围内，并递归地判断左右子树
          // 左子树的值范围为 (left, x)，右子树的值范围为 (x, right)
          return left < x && x < right &&
                 isValidBST(node.left, left, x) &&
                 isValidBST(node.right, x, right);
      }
  }
  ```

## [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

```
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
```

 

 

**提示：**

- 树中的节点数为 `n` 。
- `1 <= k <= n <= 104`
- `0 <= Node.val <= 104`

 

**进阶：**如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 `k` 小的值，你将如何优化算法？

中序遍历
上述两种节点，都没有利用该树为二叉搜索树的特性。

而我们知道，二叉搜索树的中序遍历是有序的，因此我们只需要对二叉搜索树执行中序遍历，并返回第 kkk 小的值即可。

不熟悉二叉树的中序遍历的同学，可以看看 （题解）783. 二叉搜索树节点最小距离。

中序遍历有「迭代」和「递归」两种写法。

代码：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int n = 0; // 用于记录当前第 k 小的元素的位置
    int y = 0; // 用于记录第 k 小的元素的值
    public int kthSmallest(TreeNode root, int k) {
        n = k; // 初始化 n 为 k
        kth(root); // 调用递归函数查找第 k 小的元素
        return y; // 返回第 k 小的元素的值
    }
    // 递归函数，用于查找第 k 小的元素
    public void kth(TreeNode root) {
        if(root == null || n <= 0)
            return;
        kth(root.left); // 先遍历左子树
        if(--n == 0) // 如果当前位置是第 k 小的元素，则更新 y 为当前节点的值
            y = root.val;
        kth(root.right); // 再遍历右子树
    }
}
```

## [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

**示例 2:**

```
输入: [1,null,3]
输出: [1,3]
```

**示例 3:**

```
输入: []
输出: []
```

 

**提示:**

- 二叉树的节点个数的范围是 `[0,100]`

- `-100 <= Node.val <= 100` 

  方法一层序遍历dfs

  ```java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode() {}
   *     TreeNode(int val) { this.val = val; }
   *     TreeNode(int val, TreeNode left, TreeNode right) {
   *         this.val = val;
   *         this.left = left;
   *         this.right = right;
   *     }
   * }
   */
  class Solution {
      public List<Integer> rightSideView(TreeNode root) {
      List<List<Integer>> res = new ArrayList<>(); // 用于存储层序遍历结果的列表
      Queue<TreeNode> queue = new ArrayDeque<>(); // 创建一个队列，用于辅助层序遍历
      if (root != null) { // 如果根节点不为空，将根节点加入队列
          queue.add(root);
      }
      while (!queue.isEmpty()) { // 队列不为空时执行循环
          int n = queue.size(); // 获取当前层的节点个数
          List<Integer> level = new ArrayList<>(); // 创建一个列表，用于存储当前层的节点值
          for (int i = 0; i < n; i++) { // 遍历当前层的节点
              TreeNode node = queue.poll(); // 出队列，获取当前节点
              level.add(node.val); // 将当前节点值添加到当前层的列表中
              if (node.left != null) { // 如果当前节点有左子节点，将左子节点加入队列
                  queue.add(node.left);
              }
              if (node.right != null) { // 如果当前节点有右子节点，将右子节点加入队列
                  queue.add(node.right);
              }
          }
          res.add(level); // 将当前层的列表添加到结果列表中
      }
      List<Integer> vals = new ArrayList<>(); 
      int i =0;
      for(List<Integer> treelist:res){
          int x = treelist.get(treelist.size()-1);
          vals.add(x);
      }
      return vals; // 返回层序遍历结果
      }
  }
  ```

  方法二层序遍历bfs

  ```java
  class Solution {
      private final List<Integer> ans = new ArrayList<>();
  
      public List<Integer> rightSideView(TreeNode root) {
          dfs(root, 0);
          return ans;
      }
  
      private void dfs(TreeNode root, int depth) {
          if (root == null) return;
          if (depth == ans.size())
              ans.add(root.val);
          dfs(root.right, depth + 1);
          dfs(root.left, depth + 1);
      }
  }
  ```

  
  
## [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

 

**提示：**

- 树中结点数在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

 

**进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

解题思路
本题需要将二叉树转化为列表，对于二叉树的题目，无非就以下几种解题思路：

先序遍历（深度优先搜索）
中序遍历（深度优先搜索）（尤其二叉搜索树）
后序遍历（深度优先搜索）
层序遍历（广度优先搜索）（尤其按照层来解决问题的时候）
序列化与反序列化（结构唯一性问题）
根据我们的观察，本题应该是使用深度优先搜索的方式来解决，我们看看是怎样变成一个列表的。如图所示：

![114_1.png](https://pic.leetcode-cn.com/7427f6e30a8a6e3d44375579d00b9e6eec53500b67643868817b7ad775b82adb-114_1.png)

其实是分为三步：

首先将根节点的左子树变成链表
其次将根节点的右子树变成链表
最后将变成链表的右子树放在变成链表的左子树的最右边
这就是一个递归的过程，递归的一个非常重要的点就是：不去管函数的内部细节是如何处理的，我们只看其函数作用以及输入与输出。对于函数flatten来说：

函数作用：将一个二叉树，原地将它展开为链表
输入：树的根节点
输出：无
那我们就直接根据三步来写程序就可以了

代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
        public void flatten(TreeNode root) {//每个节点都可以看成根节点
        if(root == null){
            return ;
        }
        //将根节点的左子树变成链表
        flatten(root.left);
        //将根节点的右子树变成链表
        flatten(root.right);
        TreeNode temp = root.right;
        //把树的右边换成左边的链表
        root.right = root.left;
        //记得要将左边置空
        root.left = null;
        //找到树的最右边的节点
        while(root.right != null) root = root.right;
        //把右边的链表接到刚才树的最右边的节点,其实本身是null，直接等于右边第一个节点
        root.right = temp;
    }
}
```



## [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)



给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**示例 2:**

```
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```

 

**提示:**

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` 和 `inorder` 均 **无重复** 元素
- `inorder` 均出现在 `preorder`
- `preorder` **保证** 为二叉树的前序遍历序列
- `inorder` **保证** 为二叉树的中序遍历序列



代码如下

```java
import java.util.*;
class Solution {
    HashMap<Integer, Integer> map; // 用于快速定位中序遍历数组中节点值对应的索引

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        map = new HashMap<>();
        // 将中序遍历数组的值和索引存入哈希表
        for(int i = 0; i < inorder.length; i++) 
            map.put(inorder[i], i);
        
        // 调用递归函数构建二叉树
        return dfs(preorder, 0, inorder, 0, inorder.length - 1);
    }

    // 递归函数：根据先序遍历和中序遍历构建二叉树
    // preorder: 先序遍历数组
    // p: 当前处理的先序遍历数组中的索引，即当前处理的节点在先序遍历数组中的位置
    // inorder: 中序遍历数组
    // l: 当前子树在中序遍历数组中的左边界，即当前处理的子树在中序遍历数组中的起始位置
    // r: 当前子树在中序遍历数组中的右边界，即当前处理的子树在中序遍历数组中的结束位置
    public TreeNode dfs(int[] preorder, int p, int[] inorder, int l, int r) {
        // 若子树为空，则返回 null
        if (l > r || p >= preorder.length) return null;
        
        int val = preorder[p]; // 当前子树的根节点值
        TreeNode root = new TreeNode(val); // 创建当前子树的根节点
        int index = map.get(val); // 获取当前根节点在中序遍历数组中的索引位置
        int ll = index - l; // 计算左子树的节点数量
        // 递归构建左子树和右子树
        root.left = dfs(preorder, p + 1, inorder, l, index - 1); // 构建左子树
        root.right = dfs(preorder, p + 1 + ll, inorder, index + 1, r); // 构建右子树
        
        return root; // 返回当前子树的根节点
    }
}

```



## [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

**示例 2：**

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```

 

**提示:**

- 二叉树的节点个数的范围是 `[0,1000]`
- `-109 <= Node.val <= 109` 
- `-1000 <= targetSum <= 1000` 

主要有四个地方会卡住：

前缀和定义
用它干什么
HashMap存的是什么
恢复状态代码的意义
//恢复状态代码
prefixSumCount.put(currSum, prefixSumCount.get(currSum) - 1); 
前缀和定义
一个节点的前缀和就是该节点到根之间的路径和。

拿下图解释：
节点4的前缀和为：1 + 2 + 4 = 7
节点8的前缀和：1 + 2 + 4 + 8 = 15
节点9的前缀和：1 + 2 + 5 + 9 = 17

      	  1
        /  \
       2    3
      / \    \
      4   5    6
     / \   \
    7   8   9

 











前缀和对于本题的作用
题目要求的是找出路径和等于给定数值的路径总数, 而:

两节点间的路径和 = 两节点的前缀和之差

还是拿下图解释：

                     1
                    / 
                   2    
                  / 
                 3   
                / 
               4  
假如题目给定数值为5

节点1的前缀和为: 1
节点3的前缀和为: 1 + 2 + 3 = 6

prefix(3) - prefix(1) == 5
所以 节点1 到 节点3 之间有一条符合要求的路径( 2 --> 3 )
理解了这个之后，问题就得以简化：

我们只用遍历整颗树一次，记录每个节点的前缀和，并查询该节点的祖先节点中符合条件的个数，将这个数量加到最终结果上。

HashMap存的是什么
HashMap的key是前缀和， value是该前缀和的节点数量，记录数量是因为有出现复数路径的可能。

拿图说明：

下图树中，前缀和为1的节点有两个: 1, 0

所以路径和为2的路径数就有两条: 0 --> 2, 2

      	   1
     	 / 
    	0
       /
      2

恢复状态的意义
由于题目要求：路径方向必须是向下的（只能从父节点到子节点）

当我们讨论两个节点的前缀和差值时，有一个前提：

一个节点必须是另一个节点的祖先节点

换句话说，当我们把一个节点的前缀和信息更新到map里时，它应当只对其子节点们有效。

举个例子，下图中有两个值为2的节点（A, B)。

         0
        /  \
       A:2  B:2
       / \    \
      4   5    6
     / \   \
    7   8   9

当我们遍历到最右方的节点6时，对于它来说，此时的前缀和为2的节点只该有B, 因为从A向下到不了节点6(A并不是节点6的祖先节点)。

如果我们不做状态恢复，当遍历右子树时，左子树中A的信息仍会保留在map中，那此时节点6就会认为A, B都是可追溯到的节点，从而产生错误。

状态恢复代码的作用就是： 在遍历完一个节点的所有子节点后，将其从map中除去。



代码如下

```java
class Solution {
    Map<Integer, Integer> prefixMap; // 用于存储前缀和的频率
    int target; // 目标和

    public int pathSum(TreeNode root, int sum) {
        prefixMap = new HashMap<>(); // 初始化前缀和的映射表
        target = sum; // 设置目标和

        prefixMap.put(0, 1); // 初始化前缀和为0的频率为1，表示初始时刻还没有任何节点的前缀和为0
        return recur(root, 0); // 递归计算路径和为目标和的路径数量
    }

    private int recur(TreeNode node, int curSum) {
        if(node == null) { // 如果节点为空，返回0
            return 0;
        }

        int res = 0; // 结果变量，记录以当前节点为根节点的路径和为目标和的路径数量
        curSum += node.val; // 计算当前路径和
        // 如果存在一个前缀和等于 curSum - target，说明存在一条路径和为 target
        res += prefixMap.getOrDefault(curSum - target, 0);
        // 更新前缀和映射表
        prefixMap.put(curSum, prefixMap.getOrDefault(curSum, 0) + 1); 

        // 递归计算左子树和右子树的路径和为目标和的路径数量
        int left = recur(node.left, curSum);
        int right = recur(node.right, curSum);

        res = res + left + right; // 当前节点为根节点的路径和为目标和的路径数量等于左子树、右子树和以当前节点为根节点的路径和为目标和的路径数量之和

        prefixMap.put(curSum, prefixMap.get(curSum) - 1); // 回溯，将当前前缀和的频率减1，因为已经回溯到上一层

        return res; // 返回以当前节点为根节点的路径和为目标和的路径数量
    }
}
```



## [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

 

**提示：**

- 树中节点数目在范围 `[2, 105]` 内。
- `-109 <= Node.val <= 109`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。



解题思路：
祖先的定义： 若节点 ppp 在节点 rootrootroot 的左（右）子树中，或 p=rootp = rootp=root ，则称 rootrootroot 是 ppp 的祖先。

最近公共祖先的定义： 设节点 rootrootroot 为节点 p,qp, qp,q 的某公共祖先，若其左子节点 root.leftroot.leftroot.left 和右子节点 root.rightroot.rightroot.right 都不是 p,qp,qp,q 的公共祖先，则称 rootrootroot 是 “最近的公共祖先” 。

![Picture1.png](https://pic.leetcode-cn.com/1599885247-rxcHcZ-Picture1.png)

根据以上定义，若 rootrootroot 是 p,qp, qp,q 的 最近公共祖先 ，则只可能为以下情况之一：

ppp 和 qqq 在 rootrootroot 的子树中，且分列 rootrootroot 的 异侧（即分别在左、右子树中）；
p=rootp = rootp=root ，且 qqq 在 rootrootroot 的左或右子树中；
q=rootq = rootq=root ，且 ppp 在 rootrootroot 的左或右子树中；

![Picture2.png](https://pic.leetcode-cn.com/1599885247-mgYjRv-Picture2.png)


考虑通过递归对二叉树进行先序遍历，当遇到节点 ppp 或 qqq 时返回。从底至顶回溯，当节点 p,qp, qp,q 在节点 rootrootroot 的异侧时，节点 rootrootroot 即为最近公共祖先，则向上返回 rootrootroot 。

递归解析：
终止条件：
当越过叶节点，则直接返回 nullnullnull ；
当 rootrootroot 等于 p,qp, qp,q ，则直接返回 rootrootroot ；
递推工作：
开启递归左子节点，返回值记为 leftleftleft ；
开启递归右子节点，返回值记为 rightrightright ；
返回值： 根据 leftleftleft 和 rightrightright ，可展开为四种情况；
当 leftleftleft 和 rightrightright 同时为空 ：说明 rootrootroot 的左 / 右子树中都不包含 p,qp,qp,q ，返回 nullnullnull ；
当 leftleftleft 和 rightrightright 同时不为空 ：说明 p,qp, qp,q 分列在 rootrootroot 的 异侧 （分别在 左 / 右子树），因此 rootrootroot 为最近公共祖先，返回 rootrootroot ；
当 leftleftleft 为空 ，rightrightright 不为空 ：p,qp,qp,q 都不在 rootrootroot 的左子树中，直接返回 rightrightright 。具体可分为两种情况：
p,qp,qp,q 其中一个在 rootrootroot 的 右子树 中，此时 rightrightright 指向 ppp（假设为 ppp ）；
p,qp,qp,q 两节点都在 rootrootroot 的 右子树 中，此时的 rightrightright 指向 最近公共祖先节点 ；
当 leftleftleft 不为空 ， rightrightright 为空 ：与情况 3. 同理；
观察发现， 情况 1. 可合并至 3. 和 4. 内，详见文章末尾代码。

![img](https://pic.leetcode-cn.com/1599885247-KpxUys-Picture3.png)
复杂度分析：
时间复杂度 O(N)O(N)O(N) ： 其中 NNN 为二叉树节点数；最差情况下，需要递归遍历树的所有节点。
空间复杂度 O(N)O(N)O(N) ： 最差情况下，递归深度达到 NNN ，系统使用 O(N)O(N)O(N) 大小的额外空间。

代码如下

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    /**
     * 找到二叉树中两个节点的最低公共祖先。
     * 
     * @param root 二叉树的根节点
     * @param p    一个节点
     * @param q    另一个节点
     * @return     返回p和q的最低公共祖先
     */
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 如果根节点为空，或者根节点就是p或q，直接返回根节点
        if(root == null || root == p || root == q) return root;
        // 在左子树中递归查找p和q的最低公共祖先
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        // 在右子树中递归查找p和q的最低公共祖先
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // 如果左子树中未找到，则返回右子树中找到的节点
        if(left == null) return right;
        // 如果右子树中未找到，则返回左子树中找到的节点
        if(right == null) return left;
        // 如果左右子树都找到了p和q，则当前根节点就是最低公共祖先
        return root;
    }
}
```



















# 九，图论

## [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

 

**提示：**

- `m == grid.length`

- `n == grid[i].length`

- `1 <= m, n <= 300`

- `grid[i][j]` 的值为 `'0'` 或 `'1'`

  如何避免重复遍历
  网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于，遍历中可能遇到遍历过的结点。这是因为，网格结构本质上是一个「图」，我们可以把每个格子看成图中的结点，每个结点有向上下左右的四条边。在图中遍历时，自然可能遇到重复遍历结点。

  这时候，DFS 可能会不停地「兜圈子」，永远停不下来，如下图所示：

  ![标记已遍历的格子](https://pic.leetcode-cn.com/20fe202fb5e5fc5048e140c29310c1bcbb17661860d2441e8a3feb1236a2e44d.gif)

  如何避免这样的重复遍历呢？答案是标记已经遍历过的格子。以岛屿问题为例，我们需要在所有值为 1 的陆地格子上做 DFS 遍历。每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。也就是说，每个格子可能取三个值：

  0 —— 海洋格子
  1 —— 陆地格子（未遍历过）
  2 —— 陆地格子（已遍历过）
  我们在框架代码中加入避免重复遍历的语句：

  代码如下

  ```java
  class Solution {
      //利用深度递归解决，可以看图，并加记住这个模板，他可以解决岛屿中的问题，还有一题岛屿面积问题也是这个模板。
      public int numIslands(char[][] grid) {
          //定义一个表示岛屿数量的变量
          int count = 0;
          //这个两层for循环是用来遍历整张二维表格中所有的陆地
          //其中 i 表示行，j 表示列
          for(int i = 0; i<grid.length;i++){
              for(int j =0;j<grid[0].length;j++){
                  //取出所有的陆地
                  if(grid[i][j] == '1'){
                      //深度递归，遍历所有的陆地
                      dfs(grid,i,j);
                      //用来统计有多少岛屿，岛屿是由多个陆地组成的，概念不一样
                      //因为触碰到第一个岛屿就把所有岛屿就变成2了，所以直接不会进入此循环
                      count++;
                  }
              }
          }
          //返回岛屿的数量
          return count;
      }
      public void dfs(char[][] grid,int i, int j){
          //防止 i 和 j 越界，也就是防止超出岛屿（上下左右）的范围。特别注意当遍历到海洋的时候也退出循环
          if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]=='0'||grid[i][j]=='2') 
          return;
          //将遍历过的陆地改为海洋，防止重复遍历
          grid[i][j]='2';
          //右
          dfs(grid,i,j+1);
          //下
          dfs(grid,i+1,j);
          //左
          dfs(grid,i,j-1);
          //上
          dfs(grid,i-1,j);
      }
  }
  ```




##  [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)



在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：

- 值 `0` 代表空单元格；
- 值 `1` 代表新鲜橘子；
- 值 `2` 代表腐烂的橘子。

每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。

返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`* 。

 

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png)**

```
输入：grid = [[2,1,1],[1,1,0],[0,1,1]]
输出：4
```

**示例 2：**

```
输入：grid = [[2,1,1],[0,1,1],[1,0,1]]
输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。
```

**示例 3：**

```
输入：grid = [[0,2]]
输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
```

 

**提示：**

- `m == grid.length`

- `n == grid[i].length`

- `1 <= m, n <= 10`

- `grid[i][j]` 仅为 `0`、`1` 或 `2`

  1，解题思路

  把坏的橙子都加入队列，记录好橙子的个数。for循环一次队列的长度，相当于就是那一秒的所有坏橙子往旁边腐蚀，队列移除这些坏橙子坐标，腐蚀完成后，

  再次循环队列，直到好橙子的数量为0。或者没有坏橙子，只剩下好橙子

```java
import java.util.ArrayDeque;
import java.util.Deque;

class Solution {
    public int orangesRotting(int[][] grid) {
        // 统计新鲜橙子的数量
        int freshNum = 0;
        // 使用队列进行DFS统计腐烂橙子
        Deque<int[]> queue = new ArrayDeque<>();
        // 遍历二维数组，初始化新鲜橙子数量，并将腐烂橙子坐标加入队列
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j] == 1) {
                    freshNum++; // 统计新鲜橙子数量
                }
                if (grid[i][j] == 2) {
                    queue.offer(new int[]{i, j}); // 将腐烂橙子坐标加入队列
                }
            }
        }
        int minutes = 0; // 统计经过的分钟数
        while (!queue.isEmpty()) {
            if (freshNum == 0) {
                // 如果没有新鲜橙子了，返回当前经过的分钟数
                return minutes;
            }
            // 每过去一分钟，周围的橙子开始腐烂
            minutes++;
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] rot = queue.poll(); // 取出队首的腐烂橙子
                int x = rot[0];
                int y = rot[1];
                // 对当前腐烂橙子周围的橙子进行腐烂判断
                freshNum -= roting(grid, x - 1, y, queue);
                freshNum -= roting(grid, x + 1, y, queue);
                freshNum -= roting(grid, x, y - 1, queue);
                freshNum -= roting(grid, x, y + 1, queue);
            }
        }
        // 腐烂过程结束，如果还有新鲜橙子，返回-1，否则返回经过的分钟数
        return freshNum > 0 ? -1 : minutes;
    }

    // 辅助方法，用于判断橙子是否可以腐烂
    private int roting(int[][] grid, int x, int y, Deque<int[]> queue) {
        // 判断坐标是否越界或者对应位置是否为腐烂或者空橙子
        if (x < 0 || y < 0 || x > grid.length - 1 || y > grid[0].length - 1 || grid[x][y] != 1) {
            return 0; // 如果不符合腐烂条件，返回0
        }
        // 将新鲜橙子变为腐烂橙子，并将其坐标加入队列
        grid[x][y] = 2;
        queue.offer(new int[]{x, y});
        return 1; // 返回1表示成功腐烂一个橙子
    }
}
```

输入81，4    

 2，2 

输出94，73    

3，41

## [207. 课程表](https://leetcode.cn/problems/course-schedule/)

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

**示例 2：**

```
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```

 

**提示：**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` 中的所有课程对 **互不相同**

题意解释
一共有 n 门课要上，编号为 0 ~ n-1。
先决条件 [1, 0]，意思是必须先上课 0，才能上课 1。
给你 n、和一个先决条件表，请你判断能否完成所有课程。
再举个生活的例子
先穿内裤再穿裤子，先穿打底再穿外套，先穿衣服再戴帽子，是约定俗成的。
内裤外穿、光着身子戴帽子等，都会有点奇怪。
我们遵循穿衣的一条条先后规则，用一串 顺序行为，把衣服一件件穿上。
我们遵循课程之间的先后规则，找到一种上课顺序，把所有课一节节上完。
用有向图描述依赖关系
示例：n = 6，先决条件表：[[3, 0], [3, 1], [4, 1], [4, 2], [5, 3], [5, 4]]
课 0, 1, 2 没有先修课，可以直接选。其余的课，都有两门先修课。
我们用有向图来展现这种依赖关系（做事情的先后关系）：

![微信截图_20200517052852.png](https://pic.leetcode-cn.com/de601db5bd50985014c7a6b89bca8aa231614b4ba423620dd2e31993c75a9137-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200517052852.png)

这种叫 有向无环图，把一个 有向无环图 转成 线性的排序 就叫 拓扑排序。
有向图有 入度 和 出度 的概念：
如果存在一条有向边 A --> B，则这条边给 A 增加了 1 个出度，给 B 增加了 1 个入度。
所以，顶点 0、1、2 的入度为 0。顶点 3、4、5 的入度为 2。
每次只能选你能上的课
每次只能选入度为 0 的课，因为它不依赖别的课，是当下你能上的课。
假设选了 0，课 3 的先修课少了一门，入度由 2 变 1。
接着选 1，导致课 3 的入度变 0，课 4 的入度由 2 变 1。
接着选 2，导致课 4 的入度变 0。
现在，课 3 和课 4 的入度为 0。继续选入度为 0 的课……直到选不到入度为 0 的课。
这很像 BFS
让入度为 0 的课入列，它们是能直接选的课。
然后逐个出列，出列代表着课被选，需要减小相关课的入度。
如果相关课的入度新变为 0，安排它入列、再出列……直到没有入度为 0 的课可入列。
BFS 前的准备工作
每门课的入度需要被记录，我们关心入度值的变化。
课程之间的依赖关系也要被记录，我们关心选当前课会减小哪些课的入度。
因此我们需要选择合适的数据结构，去存这些数据：
入度数组：课号 0 到 n - 1 作为索引，通过遍历先决条件表求出对应的初始入度。
邻接表：用哈希表记录依赖关系（也可以用二维矩阵，但有点大）
key：课号
value：依赖这门课的后续课（数组）
怎么判断能否修完所有课？
BFS 结束时，如果仍有课的入度不为 0，无法被选，完成不了所有课。否则，能找到一种顺序把所有课上完。
或者：用一个变量 count 记录入列的顶点个数，最后判断 count 是否等于总课程数。
代码

```java
class Solution {
        public boolean canFinish(int numCourses, int[][] prerequisites) {
        //首先创建一个map存储课程表，，比如说学习4课程的先决条件是1和2
        //那么把入度为0的顶点放在键上，值上放一个list数组，里面存放后续可以遍历的数组
        Map<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < prerequisites.length; i++) {
            List<Integer> orDefault = map.getOrDefault(prerequisites[i][1], new ArrayList<>());
            orDefault.add(prerequisites[i][0]);
            map.put(prerequisites[i][1],orDefault);
        }
        //要使用一个数组记录课程前还有其他课程有没有上完，前驱条件还有几节课没上，其实就是记录入度，为0就是可以上这个课了
        int[] log = new int[numCourses];
        for (int[] prerequisite : prerequisites) {
            log[prerequisite[0]]++;             //直接判断传过来的二维数组
        }
        //然后再创建一个队列，里面是需要依次上完所需要的课程

        ArrayDeque<Integer> deque = new ArrayDeque<>();
        for (int i = 0; i < log.length; i++) {
            //如果不为0就添加进队列
            if(log[i]==0){
                deque.offer(i);
            }
        }
        int sum = 0;
        //队列依次出队，判断map的
        while(!deque.isEmpty()){
            Integer poll = deque.poll();
            //还需要定义一个变量来判断他上完的课程和总课程是否一致
            sum++;
            if(map.containsKey(poll)){
                for(Integer  num:map.get(poll)){        //直接遍历键对应的list集合就是为Integer
                    log[num]--;
                    if (log[num]==0)
                        deque.offer(num);                 //如果入度不为0是没有添加到deque队列里的
                }
            }
        }
        return sum == numCourses;
    }
}

```



## [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

 

**示例：**

```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

 

**提示：**

- `1 <= word.length, prefix.length <= 2000`
- `word` 和 `prefix` 仅由小写英文字母组成
- `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 104` 次

我们来看个例子吧。

想象以下，包含三个单词 "sea","sells","she" 的 Trie 会长啥样呢？

它的真实情况是这样的：

![来自算法4](https://pic.leetcode-cn.com/e3c98484881bd654daa8419bcb0791a2b6f8288b58ef50df70ddaeefc4084f48-file_1575215107950)

Trie 中一般都含有大量的空链接，因此在绘制一棵单词查找树时一般会忽略空链接，同时为了方便理解我们可以画成这样：

![实际并非如此，但我们仍可这样理解](https://pic.leetcode-cn.com/3a0be6938b0a5945695fcddd29c74aacc7ac30f040f5078feefab65339176058-file_1575215106942)

接下来我们一起来实现对 Trie 的一些常用操作方法。

代码如下

```java
class Trie {

    // Trie 节点类
    class TireNode {
        private boolean isEnd; // 标记是否为一个单词的结束节点
        TireNode[] next; // 下一个节点的数组，假设只包含小写字母

        // 构造函数
        public TireNode() {
            isEnd = false; // 默认不是单词的结束节点
            next = new TireNode[26]; // 26 个小写字母
        }
    }

    private TireNode root; // Trie 的根节点

    // 构造函数，初始化 Trie
    public Trie() {
        root = new TireNode(); // 创建 Trie 根节点
    }

    // 插入一个单词到 Trie 中
    public void insert(String word) {
        TireNode node = root; // 从根节点开始
        for (char c : word.toCharArray()) { // 遍历单词的每个字符
            if (node.next[c - 'a'] == null) { // 如果当前字符的节点不存在
                node.next[c - 'a'] = new TireNode(); // 创建新节点
            }
            node = node.next[c - 'a']; // 移动到下一个节点
        }
        node.isEnd = true; // 标记当前节点为单词的结束节点
    }

    // 搜索 Trie 中是否存在一个单词
    public boolean search(String word) {
        TireNode node = root; // 从根节点开始
        for (char c : word.toCharArray()) { // 遍历单词的每个字符
            node = node.next[c - 'a']; // 移动到下一个节点
            if (node == null) { // 如果当前字符的节点不存在
                return false; // 单词不存在
            }
        }
        return node.isEnd; // 返回当前节点是否是单词的结束节点
    }

    // 检查 Trie 中是否存在以指定前缀开头的单词
    public boolean startsWith(String prefix) {
        TireNode node = root; // 从根节点开始
        for (char c : prefix.toCharArray()) { // 遍历前缀的每个字符
            node = node.next[c - 'a']; // 移动到下一个节点
            if (node == null) { // 如果当前字符的节点不存在
                return false; // 前缀不存在
            }
        }
        return true; // 前缀存在
    }
}

```

# 十，回溯

## [46. 全排列](https://leetcode.cn/problems/permutations/)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

 

**提示：**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

从全排列问题开始理解回溯算法
我们尝试在纸上写 333 个数字、444 个数字、555 个数字的全排列，相信不难找到这样的方法。以数组 [1, 2, 3] 的全排列为例。

先写以 111 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：递归结构体现在这里）；
再写以 222 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；
最后写以 333 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。
总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 当前 要选择的数字中不能出现。按照这种策略搜索就能够做到 不重不漏。这样的思路，可以用一个树形结构表示。

看到这里的朋友，建议先尝试自己画出「全排列」问题的树形结构。

![image.png](https://pic.leetcode-cn.com/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png)

说明：

每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；
使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；
深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；
深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。
使用编程的方法得到全排列，就是在这样的一个树形结构中完成 遍历，从树的根结点到叶子结点形成的路径就是其中一个全排列。

代码如下

```java
import java.util.*;

class Solution {
    public List<List<Integer>> permute(int[] nums) {
        // 创建存放排列结果的列表
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        // 调用深度优先搜索函数，传入原始数组、布尔数组、双端队列和结果列表
        dfs(nums, new boolean[nums.length], new ArrayDeque<Integer>(), list);
        return list; 
    }
    
    // 深度优先搜索函数，用于生成排列
    public void dfs(int[] nums, boolean[] used, Deque<Integer> deque, List<List<Integer>> list) {
        // 当队列大小等于原始数组长度时，表示已经完成一种排列，将其添加到结果列表中
        if(deque.size() == nums.length) {
            list.add(new ArrayList<>(deque));
            return;
        }

        // 遍历原始数组的每个元素
        for(int i = 0; i < nums.length; i++) {
            // 如果当前元素没有被使用
            if(!used[i]) {
                // 标记当前元素为已使用
                used[i] = true;
                // 将当前元素添加到双端队列中
                deque.offer(nums[i]);
                // 递归调用深度优先搜索函数
                dfs(nums, used, deque, list);
                // 回溯，将当前元素移出双端队列，并标记为未使用
                used[i] = false;
                deque.pollLast();
            }
        }
    }
}

```

## [78. 子集](https://leetcode.cn/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的

子集

（幂集）。



解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素 **互不相同**

A、 子集 - 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
解题步骤如下

①递归树

![子集问题递归树.png](https://pic.leetcode-cn.com/d8e07f0c876d9175df9f679fcb92505d20a81f09b1cb559afc59a20044cc3e8c-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%E9%80%92%E5%BD%92%E6%A0%91.png)

观察上图可得，选择列表里的数，都是选择路径(红色框)后面的数，比如[1]这条路径，他后面的选择列表只有 "2、3"，[2] 这条路径后面只有 "3" 这个选择，那么这个时候，就应该 使用一个参数 start，来标识当前的选择列表的起始位置。也就是标识每一层的状态，因此被形象的称为 "状态变量"，最终函数签名如下

```java
import java.util.*;

class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        dfs(nums, 0, new ArrayList<>(), result);
        return result;
    }

    private void dfs(int[] nums, int start, List<Integer> subset, List<List<Integer>> result) {
        result.add(new ArrayList<>(subset)); // 将当前子集添加到结果中
        // 从start位置开始，递归生成子集
        for (int i = start; i < nums.length; i++) {
            subset.add(nums[i]); // 添加当前数字到子集中
            dfs(nums, i + 1, subset, result); // 递归调用生成下一个子集
            subset.remove(subset.size() - 1); // 回溯，移除最后一个数字
        }
    }
}

```

其他思路：https://leetcode.cn/problems/subsets/solutions/229569/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-

## [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```

 

**提示：**

- `0 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。

代码如下

```java
class Solution {
    // 映射表，用于将数字映射为对应的字符集合
    private static final String[] MAPPING = new String[]{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};

    private final List<String> ans = new ArrayList<>(); // 存储最终结果的列表
    private char[] digits, path; // 用于存储数字和结果路径的字符数组

    public List<String> letterCombinations(String digits) {
        int n = digits.length();
        if (n == 0) return List.of(); // 如果输入的数字字符串为空，则直接返回空列表
        this.digits = digits.toCharArray(); // 将输入的数字字符串转换为字符数组
        path = new char[n]; // 创建用于存储结果路径的字符数组，其长度与输入数字字符串长度相同
        dfs(0); // 开始深度优先搜索
        return ans; // 返回最终结果列表
    }

    // 深度优先搜索函数，用于生成所有可能的字母组合
    private void dfs(int i) {
        if (i == digits.length) { // 如果遍历完了所有数字
            ans.add(new String(path)); // 将结果路径转换为字符串并添加到结果列表中
            return;
        }
        for (char c : MAPPING[digits[i] - '0'].toCharArray()) { // 遍历当前数字对应的字符集合
            path[i] = c; // 将当前字符添加到结果路径中
            dfs(i + 1); // 递归处理下一个数字
        }
    }
}

```

## [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

 

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

**示例 2：**

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

**示例 3：**

```
输入: candidates = [2], target = 1
输出: []
```

 **提示：**

- `1 <= candidates.length <= 30`
- `2 <= candidates[i] <= 40`
- `candidates` 的所有元素 **互不相同**
- `1 <= target <= 40`

## [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

 

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

 

**提示：**

- `1 <= n <= 8`

  ```java
  class Solution {
      private int n;
      private char[] path;
      private final List<String> ans = new ArrayList<>();
  
      public List<String> generateParenthesis(int n) {
          this.n = n;
          path = new char[n * 2];
          dfs(0, 0); // 开始深度优先搜索
          return ans;
      }
  
      private void dfs(int i, int open) {
          if (i == n * 2) { // 已经放置了 n 对括号
              ans.add(new String(path)); // 将当前路径转换为字符串并添加到结果列表中
              return;
          }
          if (open < n) { // 如果可以放置左括号
              path[i] = '('; // 放置左括号
              dfs(i + 1, open + 1); // 递归到下一个位置，并增加左括号数量
          }
          if (i - open < open) { // 如果可以放置右括号（即已放置的左括号数量大于已放置的右括号数量）
              path[i] = ')'; // 放置右括号
              dfs(i + 1, open); // 递归到下一个位置，不增加左括号数量
          }
      }
  }
  ```

  

## [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串**

 。返回 `s` 所有可能的分割方案。

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

**示例 2：**

```
输入：s = "a"
输出：[["a"]]
```

 

**提示：**

- `1 <= s.length <= 16`
- `s` 仅由小写英文字母组成

<img src=".\md图片\分割回文串1.jpg" alt="分割回文串1" style="zoom:80%;" />



![分割回文串2](.\md图片\分割回文串2.jpg)



解题思路，其实跟子集问题差不多，有两个指针，一个是判断当前回文串的起始指针，一个是判断当前回文串的末尾指针。

逐一对比，如果都一样，就为true执行下面的逻辑

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    // 存储最终结果的列表
    private final List<List<String>> ans = new ArrayList<>();
    // 存储当前路径的列表
    private final List<String> path = new ArrayList<>();
    // 输入字符串
    private String s;

    // 主函数，用于返回所有可能的回文串分割
    public List<List<String>> partition(String s) {
        this.s = s;
        dfs(0, 0); // 调用深度优先搜索函数
        return ans; // 返回结果列表
    }

    // 判断是否为回文串的函数
    private boolean isPalindrome(int left, int right) {
        while (left < right)
            if (s.charAt(left++) != s.charAt(right--))
                return false;
        return true;
    }

    // 深度优先搜索函数
    // start表示当前回文子串的起始位置，i表示当前字符的索引， i 和 i+1 之间为逗号
    private void dfs(int start，int i) {
        if (i == s.length()) {
            ans.add(new ArrayList<>(path)); // 将当前路径加入结果列表
            return;
        }
        // 不选 i 和 i+1 之间的逗号（i=n-1 时一定要选）,相当于依次遍历，然后依次返回继续下面的逻辑
        if (i < s.length() - 1)
            dfs(i + 1, start);
        // 选 i 和 i+1 之间的逗号（把 s[i] 作为子串的最后一个字符）
        if (isPalindrome(start, i)) {
            path.add(s.substring(start, i + 1)); // 将回文子串加入当前路径
            dfs(i + 1, i + 1); // 继续搜索下一个子串，起始位置为 i+1,判断已经添加的这一种可能的后续可能
            path.remove(path.size() - 1); // 恢复现场，移除最后加入的子串
        }
    }
}

```



# 十一，二分查找

## [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

 

**示例 1:**

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

**示例 2:**

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

**示例 3:**

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

 

**提示:**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 为 **无重复元素** 的 **升序** 排列数组
- `-104 <= target <= 104`

代码如下

```java
public class Solution {

    public int searchInsert(int[] nums, int target) {
        // 不用判断数组为空，因为题目最后给出的数据范围说数组不为空
        int len = nums.length;
        // 特殊判断
        if (nums[len - 1] < target) {
            return len;
        }

        // 程序走到这里一定有 nums[len - 1] >= target，插入位置在区间 [0..len - 1]
        int left = 0;
        int right = len - 1;
        // 在区间 nums[left..right] 里查找第 1 个大于等于 target 的元素的下标
        while (left < right) {
            int mid = (left + right) / 2;
            if(nums[mid] == target)
            return mid ;
            if (nums[mid] < target){
                // 下一轮搜索的区间是 [mid + 1..right]
                left = mid + 1;
            } else {
                // 下一轮搜索的区间是 [left..mid]
                right = mid;
            }
        }
        return left;
    }
}
```







## [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

给你一个满足下述两条属性的 `m x n` 整数矩阵：

- 每行中的整数从左到右按非严格递增顺序排列。
- 每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg)

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
```

 

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 100`
- `-104 <= matrix[i][j], target <= 104`

代码如下

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        // 获取矩阵的行数和列数
        int n = matrix.length;
        int m = matrix[0].length;
        // 计算矩阵中元素的总个数
        int end = n * m;
        int begin = 0;
        int left;
        int right;
        while (begin < end) {
            // 二分搜索的中间值
            int i = (begin + end) / 2;
            // 根据中间值计算行和列索引
            left = i / m;
            right = i % m;
            // 如果目标值等于当前矩阵元素，返回true
            if (target == matrix[left][right])
                return true;
            // 如果目标值大于当前矩阵元素，缩小搜索范围为右半部分
            else if (target > matrix[left][right])
                begin = i + 1;
            // 如果目标值小于当前矩阵元素，缩小搜索范围为左半部分
            else if (target < matrix[left][right])
                end = i;
        }
        // 没有找到目标值，返回false
        return false;
    }
}

```



## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

 

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

 

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
- `nums` 是一个非递减数组
- `-109 <= target <= 109`

解题思路先用二分查找，找到目标值，再逐步扩展边界，得到a，b

代码如下

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int end = nums.length - 1;
        int begin = 0;
        int a = -1, b = -1; // 初始化左右边界为-1
        while (begin <= end) { // 注意这里是 <=
            int i = (begin + end) / 2;
            if (target == nums[i]) {
                a = i;
                b = i;
                // 向左搜索边界
                while (a - 1 >= 0 && nums[a - 1] == target) {
                    a--;
                }
                // 向右搜索边界
                while (b + 1 < nums.length && nums[b + 1] == target) {
                    b++;
                }
                break;
            } else if (target > nums[i]) {
                begin = i + 1;
            } else if (target < nums[i]) {
                end = i - 1;
            }
        }
        return new int[]{a, b};
    }
}

```



## [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

 

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1
```

 

**提示：**

- `1 <= nums.length <= 5000`
- `-104 <= nums[i] <= 104`
- `nums` 中的每个值都 **独一无二**
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- `-104 <= target <= 104`

解题思路，实际上需要两个索引，一个是最小值的索引，可以把整个数组，分成两段

然后把target跟数组最后一位相比，因为这个索引也是数组的分界线，

比如说4567123

最小值就是1，左侧是4567，右侧是123

假设taget为2那么比3小，就是123这个区间

假设taget为5那么比3大，就是4567这个区间

代码如下

```java
class Solution {
    public int search(int[] nums, int target) {
        // 找到最小值的索引
        int i = findMin(nums);
        // 如果目标值大于数组中的最大值，那么在左侧段搜索
        if (target > nums[nums.length - 1])
            return lowerBound(nums, -1, i, target); // 左侧段
        // 否则，在右侧段搜索
        return lowerBound(nums, i - 1, nums.length, target); // 右侧段
    }

    // 寻找数组中的最小值的索引
    private int findMin(int[] nums) {
        int n = nums.length;
        int left = -1, right = n - 1; // 左右边界为开区间 (-1, n-1)
        while (left + 1 < right) { // 开区间不为空
            int mid = left + (right - left) / 2;
            if (nums[mid] < nums[n - 1]) right = mid; // 如果中间值小于最后一个值，则最小值在左侧
            else left = mid; // 否则最小值在右侧
        }
        return right; // 返回最小值的索引
    }

    // 二分搜索，找到第一个大于等于目标值的索引
    private int lowerBound(int[] nums, int left, int right, int target) {
        while (left + 1 < right) { // 开区间不为空
            // 循环不变量：nums[left] < target，nums[right] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target)
                left = mid; // 范围缩小到 (mid, right)
            else
                right = mid; // 范围缩小到 (left, mid)
        }
        // 返回目标值的索引，如果未找到目标值则返回 -1
        return nums[right] == target ? right : -1;
    }
}

```



## [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

 

**示例 1：**

```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。
```

**示例 3：**

```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` 中的所有整数 **互不相同**
- `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转

不断对比最右边的的数字，然后选择区间继续，直到找到最小值

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0; // 初始化左边界
        int right = nums.length - 1; // 初始化右边界
        while (left < right) { // 当左边界小于右边界时进行循环
            int mid = left + (right - left) / 2; // 计算中间索引
            if (nums[mid] < nums[right]) { // 如果中间值小于右边界值，最小值在左侧或者是 mid 位置
                right = mid; // 更新右边界为 mid
            } else { // 否则最小值在右侧
                left = mid + 1; // 更新左边界为 mid + 1
            }
        }
        return nums[left]; // 返回最小值
    }
}

```

# 十二，栈

## [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

 

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

 

**提示：**

- `1 <= s.length <= 104`
- `s` 仅由括号 `'()[]{}'` 组成

代码如下

```java
import java.util.*;

class Solution {
    // 建立映射关系，左括号作为键，右括号作为值
    private static final Map<Character, Character> map = new HashMap<>() {{
        put('(', ')');
        put('{', '}');
        put('[', ']');
        put('?', '?'); // 用于处理空字符串的情况
    }};

    // 判断括号序列是否有效
    public boolean isValid(String str) {
        // 如果字符串不为空且第一个字符不是左括号，直接返回 false
        if (str.length() > 0 && !map.containsKey(str.charAt(0)))
            return false;
        
        // 使用链表作为栈，初始放入一个占位符 '?'
        List<Character> stack = new LinkedList<>();
        stack.add('?');
        
        // 遍历字符串中的每个字符
        for (char ch : str.toCharArray()) {
            if (map.containsKey(ch)) { // 如果是左括号，将其入栈
                stack.add(ch);
            } else { // 如果是右括号
                // 弹出栈顶元素，并与当前右括号进行匹配
                if (map.get(stack.remove(stack.size() - 1)) != ch)
                    return false; // 如果匹配失败，返回 false
            }
        }
        // 最终栈中只剩下一个占位符，说明括号序列有效
        return stack.size() == 1;
    }
}

```



## [155. 最小栈](https://leetcode.cn/problems/min-stack/)

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

 

**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

 

**提示：**

- `-231 <= val <= 231 - 1`
- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and `getMin`最多被调用 `3 * 104` 次

代码如下

```java
class MinStack {
    // 主要存储栈元素的双端队列
    private Deque<Integer> deque;
    // 存储最小元素的双端队列
    private Deque<Integer> deque2;

    // 构造方法，初始化两个双端队列，没有（）
    public MinStack() {
        deque = new ArrayDeque<>();
        deque2 = new ArrayDeque<>();
    }

    // 将元素压入栈
    public void push(int val) {
        // 将元素压入主要存储栈的双端队列中
        deque.offer(val);
        // 如果最小元素队列为空，或者新元素比最小元素队列的栈顶元素小，则将新元素压入最小元素队列
        if (deque2.isEmpty() || deque2.peekLast() >= val)
            deque2.offer(val);
    }

    // 弹出栈顶元素
    public void pop() {
        // 移除主要存储栈的栈顶元素
        int removed = deque.pollLast();
        // 如果移除的是当前最小值，则也要从最小元素队列中移除
        if (removed == deque2.peekLast()) {
            deque2.pollLast();
        }
    }

    // 获取栈顶元素
    public int top() {
        // 返回主要存储栈的栈顶元素
        return deque.peekLast();
    }

    // 获取栈中的最小元素
    public int getMin() {
        // 返回最小元素队列的栈顶元素，即当前栈中的最小值
        return deque2.peekLast();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */

```



## [394. 字符串解码](https://leetcode.cn/problems/decode-string/)

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

 

**示例 1：**

```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

**示例 2：**

```
输入：s = "3[a2[c]]"
输出："accaccacc"
```

**示例 3：**

```
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

**示例 4：**

```
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

 

**提示：**

- `1 <= s.length <= 30`
- `s` 由小写英文字母、数字和方括号 `'[]'` 组成
- `s` 保证是一个 **有效** 的输入。
- `s` 中所有整数的取值范围为 `[1, 300]` 



解法一：辅助栈法

- 本题难点在于括号内嵌套括号，需要**从内向外**生成与拼接字符串，这与栈的**先入后出**特性对应。

先要初始化一个 StringBuilder 以存储解码后的字符串，初始化一个变量以跟踪当前的乘数，初始化两个栈ArrayDeque来存储乘数和部分结果，

然后创建一个for循环依次判断字符串的每一个字符，分别处理的逻辑，StringBuilder的作用很关键

```java
class Solution {
    public String decodeString(String s) {
        // 初始化一个 StringBuilder 以存储解码后的字符串
        StringBuilder res = new StringBuilder();
        // 初始化一个变量以跟踪当前的乘数
        int multi = 0; 
        // 初始化两个栈来存储乘数和部分结果
        Deque<Integer> stack_multi = new ArrayDeque<>();
        Deque<String> stack_res = new ArrayDeque<>();
        
        // 遍历输入字符串中的每个字符
        for(Character c : s.toCharArray()) {
            // 如果字符是一个左括号 '['
            if(c == '[') {
                // 将当前乘数推入乘数栈
                stack_multi.addLast(multi);
                // 将当前部分结果推入结果栈
                stack_res.addLast(res.toString());
                // 重置乘数和结果 StringBuilder 以准备处理新的嵌套字符串
                multi = 0;
                res = new StringBuilder();
            }
            // 如果字符是一个右括号 ']'
            else if(c == ']') {
                // 创建一个临时 StringBuilder 以存储重复的字符串
                StringBuilder tmp = new StringBuilder();
                // 从乘数栈中取出当前乘数
                int cur_multi = stack_multi.removeLast();
                // 将当前结果重复 'cur_multi' 次并附加到 tmp 中
                for(int i = 0; i < cur_multi; i++){
                    tmp.append(res);
                    }
                // 从结果栈中取出上一个部分结果
                // 将重复的字符串（tmp）附加到其中
                res = new StringBuilder(stack_res.removeLast() + tmp);
            } 
            // 如果字符是一个数字，则更新乘数
            else if(c >= '0' && c <= '9')
                multi = multi * 10 + (c -'0');
            // 如果字符既不是括号也不是数字，则简单地将其附加到结果 StringBuilder 中
            else
                res.append(c);
        }
        // 返回解码后的字符串
        return res.toString();
    }
}

```

假设s = "3[a2[c]]"

3，那么multi先变成3												

[,    3存入stack_multi，然后把一个空res存入stack_res,	multi和res置空       stack_multi=3	stack_res=' ',

a,   res添加‘a’,res=a

2,   那么multi变成2

[,    2存入stack_multi，然后把a存入stack_res,	multi和res置空                    stack_multi=3,2	stack_res=' ',  a

c,     res添加‘c’,res=c

],    stack_multi取出2，然后循环2次，把当前res重复添加两次到temp临时变量，temp = cc   ，  stack_res取出括号之间的字符串，a，进行拼接，res=acc，stack_multi=3	stack_res=' '

],     stack_multi取出3，然后循环3次，把当前res重复添加3次到temp临时变量，temp = accaccacc， stack_res取出括号之间的字符串，"'"，进行拼接，res=accaccacc ， stack_multi=	stack_res=

return res.toString();结束

## [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

 

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

 

**提示：**

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`

------

代码如下，运用单调栈

```java
import java.util.ArrayDeque;
import java.util.Deque;

class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] ans = new int[n]; // 存放结果的数组
        Deque<Integer> st = new ArrayDeque<>(); // 单调递减栈，存放下标

        // 从后向前遍历温度数组
        for (int i = n - 1; i >= 0; i--) {
            int t = temperatures[i]; // 当前温度
            // 如果栈不为空且当前温度大于等于栈顶温度，则弹出栈顶元素
            //isEmpty一定要取反
            while (!st.isEmpty() && t >= temperatures[st.peek()]) {
                st.pop();
            }
            // 如果栈不为空，计算当前温度与栈顶温度的索引差值，即为对应的等待天数
            //isEmpty一定要取反,因为空返回true
            if (!st.isEmpty()) {
                ans[i] = st.peek() - i;
            }
            // 将当前下标压入栈中,在if外面，因为无论如何,经过弹栈，都要压入栈
            st.push(i);
        }
        // 返回结果数组
        return ans;
    }
}

```

​	

# 十三，堆

## [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

 

**示例 1:**

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

 

**提示：**

- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
            Arrays.sort(nums);
            return nums[nums.length-k];
    }
}
```



## [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)



给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

 

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

 

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

 

**进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。



解法二：最小堆
题目最终需要返回的是前 kkk 个频率最大的元素，可以想到借助堆这种数据结构，对于 kkk 频率之后的元素不用再去处理，进一步优化时间复杂度。


![img](https://pic.leetcode-cn.com/2b27b1db106a53abe239c5be8e49a800522ab2f6637940cb556bcfe1232ff333-file_1561712388055)

具体操作为：

借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率
维护一个元素数目为 kkk 的最小堆
每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较
如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中
最终，堆中的 kkk 个元素即为前 kkk 个高频元素

![堆中的元素就是前 k 个频率最大的元素](https://pic.leetcode-cn.com/b548a3796066fa7072baa2b1e06e0d54641a7913d87c88c61d73b6b9ad0e90db-file_1561712388100)

代码如下：

其实重点在于集合的创建和函数编程的写法,PriorityQueue是 Java 中的一个实现了优先队列（Priority Queue）数据结构的类。

```java
import java.util.*;

class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // 创建一个HashMap来计数每个数字出现的频率
        Map<Integer, Integer> counter = new HashMap<>();
        for(int num : nums) {
            counter.merge(num, 1, Integer::sum); // 如果数字已存在，则增加其频率；否则将频率设置为1
        }
        
        // 创建一个最大堆，堆中存储数组，数组的第一个元素为数字的频率，第二个元素为数字本身
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> b[0] - a[0]); // 最大堆
        
        // 将计数器中的每个键值对（数字及其频率）添加到堆中
        for(Map.Entry<Integer, Integer> map : counter.entrySet()) {
            heap.offer(new int[]{map.getValue(), map.getKey()}); // 按次数排序，所以[0]传的是计数值
        }
        
        // 创建结果数组，取出堆中的前k个元素（即出现频率最高的k个数字），并将它们存储在结果数组中
        int[] res = new int[k];
        for(int i = 0; i < k; i++) {
            res[i] = heap.poll()[1]; // 从堆中取出元素，数组的第二个元素即为数字本身
        }
        
        // 返回结果数组
        return res;
    }
}

```

# 十四，贪心算法

## [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

 

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

 

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 104`

从左到右枚举卖出价格 prices[i]\textit{prices}[i]prices[i]，那么要想获得最大利润，我们需要知道第 iii 天之前，股票价格的最小值是什么，也就是从 prices[0]\textit{prices}[0]prices[0] 到 prices[i−1]\textit{prices}[i-1]prices[i−1] 的最小值，把它作为买入价格，这可以用一个变量 minPrice\textit{minPrice}minPrice 维护。

请注意，minPrice\textit{minPrice}minPrice 维护的是 prices[i]\textit{prices}[i]prices[i] 左侧元素的最小值。

由于只能买卖一次，所以在遍历中，维护 prices[i]−minPrice\textit{prices}[i]-\textit{minPrice}prices[i]−minPrice 的最大值，就是答案。

代码如下

```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0; // 初始化最大利润为0
        int minPrice = prices[0]; // 初始化最低价格为数组第一个元素
        for (int p : prices) { // 遍历价格数组
            ans = Math.max(ans, p - minPrice); // 更新最大利润，当前价格减去最低价格
            minPrice = Math.min(minPrice, p); // 更新最低价格，取当前价格和已知最低价格的最小值
        }
        return ans; // 返回最大利润
    }
}
```



## [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

 

**提示：**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 105`

代码如下

```java
class Solution {
    public boolean canJump(int[] nums) {
        if (nums.length == 0) // 判断数组是否为空
            return false;
        int n = nums[0]; // 初始化最远可到达的位置为第一个元素的值
        for (int i = 0; i <= n; i++) {
            if (i == nums.length - 1) // 如果当前位置已经到达数组末尾，则返回true
                return true;
            n = Math.max(nums[i] + i, n); // 更新最远可到达的位置
        }
        return false;
    }
}
```



## [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

 

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```
输入: nums = [2,3,0,1,4]
输出: 2
```

 

**提示:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `nums[n-1]`

代码如下

```java
class Solution {
    public int jump(int[] nums) {
        if (nums.length == 0) // 判断数组是否为空
            return 0;
        int end1 = 0; // 当前跳跃步数所能到达的最远位置
        int end2 = 0; // 下一跳步数所能到达的最远位置
        int num = 0; // 记录跳跃步数

        for (int i = 0; i <= nums.length-1; i++) {
            if (i == nums.length - 1) {
                    return num;                     //最后一次判断，防止突发情况
            }
            end2 = Math.max(nums[i]+i,end2); // 更新下一跳步数所能到达的最远位置
            // 如果当前位置到达上一步所能到达的最远位置，则更新最远位置并增加步数
            if(end1==i){
                end1=end2;
                num++;
            }
        }
        // 返回跳跃步数
        return num;
    }
}
```



## [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

 

**示例 1：**

```
输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
```

**示例 2：**

```
输入：s = "eccbbbbdec"
输出：[10]
```

 

**提示：**

- `1 <= s.length <= 500`
- `s` 仅由小写英文字母组成

```java
import java.util.*;

class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> result = new ArrayList<>();
        if (s == null || s.length() == 0)
            return result;

        char[] ch = s.toCharArray();
        Map<Character, int[]> map = new LinkedHashMap<>();

        // 遍历字符串，记录每个字符第一次出现的索引和最后一次出现的索引
        for (int i = 0; i < ch.length; i++) {
            char c = ch[i];
            if (!map.containsKey(c)) {
                map.put(c, new int[] { i, i });
            } else {
                map.get(c)[1] = i;
            }
        }

        // 合并重叠的区间
        int start = -1, end = -1;
        for (int[] interval : map.values()) {
            if (start == -1) {
                start = interval[0];
                end = interval[1];
            } else {
                if (interval[0] > end) {
                    result.add(end - start + 1);
                    start = interval[0];
                    end = interval[1];
                } else {
                    end = Math.max(end, interval[1]);
                }
            }
        }
        // 加入最后一个片段的长度
        result.add(end - start + 1);

        return result;
    }
}

```

# 十五，动态规划

## [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

 

**提示：**

- `1 <= n <= 45`

 代码如下

```java
class Solution {
    public int climbStairs(int n) {
        int p = 0, q = 0, r = 1; // 初始化前两级台阶的爬法：p表示倒数第二级台阶的爬法，q表示倒数第一级台阶的爬法，r表示当前级台阶的爬法
        for (int i = 1; i <= n; ++i) { // 从第一级台阶开始逐级计算爬法
            p = q; // 更新倒数第二级台阶的爬法为倒数第一级台阶的爬法
            q = r; // 更新倒数第一级台阶的爬法为当前级台阶的爬法
            r = p + q; // 当前级台阶的爬法等于前两级台阶爬法之和
        }
        return r; // 返回到达第n级台阶的爬法
    }
}

```



## [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

 

**示例 1:**

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**示例 2:**

```
输入: numRows = 1
输出: [[1]]
```

 

**提示:**

- `1 <= numRows <= 30`

分析可知每一行的数字除了第一个和最后一个数，中间的数为上一行 i 和 i-1 的元素之和

代码如下

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<List<Integer>> generate(int numRows) {
        // 用于存储最终的杨辉三角形式的二维列表
        List<List<Integer>> lists = new ArrayList<>();

        // 遍历每一行，生成杨辉三角形式的二维列表
        for (int i = 0; i < numRows; i++) {
            // 当前行的列表，用于存储当前行的元素
            List<Integer> currentRow = new ArrayList<>();

            // 遍历当前行的每一个元素
            for (int j = 0; j <= i; j++) {
                // 当前元素为当前行的首尾元素，值为1
                if (j == 0 || j == i) {
                    currentRow.add(1);
                } else {
                    // 当前元素为上一行对应位置元素的和
                    List<Integer> previousRow = lists.get(i - 1);
                    int sum = previousRow.get(j - 1) + previousRow.get(j);
                    currentRow.add(sum);
                }
            }
            // 将当前行添加到二维列表中
            lists.add(currentRow);
        }

        // 返回生成的二维列表
        return lists;
    }
}
```



## [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

代码如下：

```java
class Solution {
    public int rob(int[] nums) {
        // 处理特殊情况：如果数组为空，则返回0
        if (nums == null || nums.length == 0)
            return 0;
        
        // 处理特殊情况：如果只有一间房屋，则返回该房屋的金额
        if (nums.length == 1)
            return nums[0];
        
        // 处理特殊情况：如果只有两间房屋，则返回最大的金额
        if (nums.length == 2)
            return Math.max(nums[0], nums[1]);
        
        // 创建一个数组 dp 用于存储偷取前 i 间房屋能获得的最大金额
        int[] dp = new int[nums.length];
        
        // 初始化 dp 数组的前两个值
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        
        // 动态规划：计算偷取前 i 间房屋能获得的最大金额
        for (int i = 2; i < nums.length; i++) {
            // 当前房屋有两种选择：偷取当前房屋或者不偷取当前房屋
            // 如果偷取当前房屋，则不能偷取前一个房屋，偷取金额为 dp[i-2] + nums[i]
            // 如果不偷取当前房屋，则偷取金额为 dp[i-1]
            dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
        }
        
        // 返回偷取前 nums.length 间房屋能获得的最大金额
        return dp[nums.length - 1];
    }
}

```



## [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)



给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

 

**提示：**

- `1 <= n <= 104`

解题思路，既然要找最小的数，那么最0依次开始找每个数的最少数量，一直到给的数n

最重要的是这句代码

```java
dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
i代表当前遍历到的数字，j*j代表的是一个数，只是用j*j代表而已13-9是13-3*3
dp[i - j * j] + 1意思就为dp[4]+1,dp[4]里存的就是4的完全平方数的最少数量，再加上9（3*3）也就是+1,
13 = 9+4,结果为2
```

代码如下

```java
class Solution {
    public int numSquares(int n) {
        // 创建一个长度为 n+1 的数组 dp，用于存储和为 i 的完全平方数的最少数量
        int[] dp = new int[n + 1];     
        // 初始化 dp 数组，将所有元素初始化为最大值 Integer.MAX_VALUE
        Arrays.fill(dp, Integer.MAX_VALUE);      
       // 当和为 0 时，需要 0 个完全平方数
        dp[0] = 0; 
        // 动态规划：计算和为 i 的完全平方数的最少数量
        for (int i = 1; i <= n; i++) {
            // 尝试每一个完全平方数 j*j，其中 j*j <= i
            for (int j = 1; j * j <= i; j++) {
                // 如果当前和为 i-j*j 的最少数量加上 1 比 dp[i] 小，则更新 dp[i]
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }
        // 返回和为 n 的完全平方数的最少数量
        return dp[n];
    }
}
```



## [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

 

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

 

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`

代码如下

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        // 创建一个数组 dp，长度为 amount + 1，用于存储凑成每个金额所需的最少硬币数量
        // 定义子问题 F(S): 组成金额S所需的最少金币数量    F(S) = F(S-C) + 1;
        int[] dp = new int[amount + 1];
        // 初始化 dp 数组，将所有元素初始化为一个较大的值，表示暂时无法凑成对应金额
        Arrays.fill(dp, Integer.MAX_VALUE);     
        // 设置凑成金额为 0 的最少硬币数量为 0
        dp[0] = 0;
        // 动态规划：逐步计算凑成每个金额所需的最少硬币数量
        for (int i = 1; i <= amount; i++) {
            // 遍历硬币数组 coins
            for (int coin : coins) {
                // 如果当前硬币的面额小于等于当前金额 i，并且使用当前硬币后剩余金额可凑成（不为初始值）
                //意思就是减掉后的数不是初始值
                if (coin <= i && dp[i - coin] != Integer.MAX_VALUE) {
                    // 更新凑成金额 i 的最少硬币数量为当前硬币数量加上使用当前硬币后剩余金额的最少硬币数量
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        // 返回凑成总金额 amount 所需的最少硬币数量，若为初始值则表示无法凑成则返回 -1
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}

```



## [139. 单词拆分](https://leetcode.cn/problems/word-break/)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```



代码如下

```java
import java.util.*;
public class Solution {
    /**
     * 判断字符串是否可以由字典中的一个或多个单词拼接而成
     * @param s 待判断的字符串
     * @param wordDict 字符串列表，作为字典
     * @return 如果可以拼接成字符串 s 则返回 true，否则返回 false
     */
    public boolean wordBreak(String s, List<String> wordDict) {
        // 将单词列表转换为集合，方便快速查找
        Set<String> wordSet = new HashSet<>(wordDict);
        
        int n = s.length();
        // dp[i] 表示字符串 s 的前 i 个字符是否可以由字典中的单词拼接而成
        boolean[] dp = new boolean[n + 1];
        dp[0] = true; // 空字符串可以被拼接
        
        // 遍历字符串 s 中的每个字符
        for (int i = 1; i <= n; i++) {
            // 遍历字典中的每个单词
            for (String word : wordSet) {
                // 如果前缀可以被拼接，并且剩余的部分在单词列表中，则当前位置可以被拼接
                if (i - word.length() >= 0 
                && dp[i - word.length()] 
                //substring是取字符串 s 中从索引 i - word.length() 开始到索引 i 之间的子串。
                //再equals进行对比
                && s.substring(i - word.length(), i).equals(word)) {
                    //如果是就为true,比如s为"leetcode"
                    //轮循到leet，检查4-4=0检查dp[0]为true,dp[4]设置true
                     //轮循到code，检查8-4=4，检查dp[4]为true,dp[8]设置true
                    dp[i] = true;
                    break;
                }
            }
        }
        // 返回最后一个位置的状态，表示是否可以被拼接
        return dp[n];
    }
}
```



## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的

子序列

。



 

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

 

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

 

**进阶：**

- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

```java
public class Solution {
      public int lengthOfLIS(int[] nums) {
        // 如果数组为空，则最长递增子序列长度为 0
        if (nums.length == 0)
            return 0;
        // 如果数组只有一个元素，则最长递增子序列长度为 1
        if (nums.length == 1)
            return 1;
        
        // 获取数组长度
        int n = nums.length;
        // 创建一个数组来存储最长递增子序列的长度
        int[] dp = new int[n];
        // 使用 1 来初始化 dp 数组，因为每个元素自身构成的子序列的长度至少为 1
        Arrays.fill(dp, 1);
        
        // 初始化最大长度为 1，因为数组至少有一个元素
        int max = 1;
        
        // 遍历数组，计算每个位置的最长递增子序列长度
        for (int k = 1; k < n; k++) {
            // 对于当前位置 k，遍历其之前的位置 i
            for (int i = 0; i < k; i++) {
                // 如果 nums[k] 大于 nums[i]，则表示 nums[k] 可以接在 nums[i] 后面形成一个更长的递增子序列
                if (nums[k] > nums[i]) {
                    // 更新 dp[k]，取当前 dp[k] 和 dp[i] + 1 中的较大值
                    dp[k] = Math.max(dp[k], dp[i] + 1);
                }
            }
            // 更新最大长度
            max = Math.max(dp[k], max);
        }
        // 返回最长递增子序列的长度
        return max;
    }
}
```



## [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续

子数组

（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。



测试用例的答案是一个 **32-位** 整数。

 

**示例 1:**

```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

解题思路

和上面几道题差不多，也是创建dp数组，逐一填充每个数的乘积最大的非空连续子数组

最终得到答案，因为有负数的存在，所以需要添加一个最小数组来进行辅助

```java
class Solution {
public int maxProduct(int[] nums) {
    // 如果数组只有一个元素，则直接返回该元素作为最大乘积
    if (nums.length == 1)
        return nums[0];
    
    // 获取数组长度
    int n = nums.length;
    // 创建一个数组来存储最大乘积和最小乘积
    int[] maxDp = new int[n]; // 存储最大乘积的数组
    int[] minDp = new int[n]; // 存储最小乘积的数组
    maxDp[0] = nums[0]; // 初始化最大乘积数组
    minDp[0] = nums[0]; // 初始化最小乘积数组
    int max = nums[0]; // 记录最大乘积的变量
    
    // 遍历数组，计算每个位置的最大乘积和最小乘积
    for (int i = 1; i < n; i++) {
        // 负数可能导致最大乘积和最小乘积的互相转换，所以要同时维护最大乘积和最小乘积
        maxDp[i] = Math.max(Math.max(nums[i] * maxDp[i - 1], nums[i] * minDp[i - 1]), nums[i]);
        minDp[i] = Math.min(Math.min(nums[i] * maxDp[i - 1], nums[i] * minDp[i - 1]), nums[i]);
        // 更新最大乘积
        max = Math.max(maxDp[i], max);
    }
    
    // 返回最大乘积
    return max;
    }
}
```



## [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

代码如下

是一个经典的01背包问题

奇数直接返回flase

然后只要找到子数组加起来等于sum/2的数就行

从sum/2遍历，倒叙遍历



```
dp[i] = dp[i] ||	dp[ sum/2 - num];  num 为nums数组其中一个数字，假设是dp[11-6] = dp[5] ,而之前dp[5-5]=dp[0],dp[0]为true，
那么装上物品6和5，总重量11就为true
```

代码如下

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        // 如果数组的和是奇数，无法分割成两个和相等的子集
        if (sum % 2 != 0) {
            return false;
        }
        // 背包的容量为 sum / 2
        int target = sum / 2;
        // dp[i] 表示容量为 i 的背包能否恰好装满
        boolean[] dp = new boolean[target + 1];
        dp[0] = true; // 容量为 0 的背包始终能装满

            for (int num:nums){ 
                for (int i = target; i >=num; i--) {   //需要注意>=num，而不是0，
                                                        //否则会数组越界
                dp[i] = dp[i] || dp[i-num];     
            }
        }
        return dp[target];
    }
}
```



# 十六，多维动态规划

## 	[62. 不同路径](https://leetcode.cn/problems/unique-paths/)



一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

**示例 1：**

![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

 

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 109`

​	解题思路

注意分析题意，他是求得是路径次数，而不是走的步数

而且只能往右或下走，那么第一行和第一列的点都是路径次数都是一次

而每一个点的次数`dp[i][j] = dp[i-1][j] + dp[i][j-1]` 这行代码表示到达位置 `(i, j)` 的不同路径数等于到达其上方位置 `(i-1, j)` 和左方位置 `(i, j-1)` 的路径数之和，因为机器人每次只能向下或向右移动一步。

```java
class Solution {
public int uniquePaths(int m, int n) {
    // 创建一个二维数组来存储不同路径数
    int[][] dp = new int[m][n];
    
    // 初始化第一行和第一列的路径数都为 1
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1; // 第一列的路径数都为 1
    }
    for (int j = 0; j < n; j++) {
        dp[0][j] = 1; // 第一行的路径数都为 1
    }
    
    // 计算其他位置的路径数
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            // 状态转移方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    
    // 返回右下角位置的路径数，即到达目标点的不同路径数
    return dp[m-1][n-1];
}
}
```



## [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**示例 2：**

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 200`

解题思路

这道题跟上道题差不多，主要使用dp数组依次记录每一个点的最小数，最后遍历到最后一个数字

```java
 // 返回右下角位置的最小路径和
    return dp[m - 1][n - 1];
```

重要的是初始化第一列和第一行的最小数，方便后续遍历，避免数组越界

```java
class Solution {
    public int minPathSum(int[][] grid) {
        // 获取网格的行数和列数
        int m = grid.length;
        int n = grid[0].length;
        // 创建一个二维数组来存储每个位置的最小路径和
        int[][] dp = new int[m][n];
        // 初始化起点的最小路径和
        dp[0][0] = grid[0][0];
        // 初始化第一列的最小路径和
        for (int i = 1; i < m; i++) {
            dp[i][0] = grid[i][0] + dp[i - 1][0]; 
        }
        // 初始化第一行的最小路径和
        for (int j = 1; j < n; j++) {
            dp[0][j] = grid[0][j] + dp[0][j - 1]; 
        }
        // 计算其他位置的最小路径和
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                // 当前位置的最小路径和为从上方和左方两个位置中选择较小的值，并加上当前位置的值
                dp[i][j] = Math.min(grid[i][j] + dp[i - 1][j], grid[i][j] + dp[i][j - 1]);
            }
        }
        // 返回右下角位置的最小路径和
        return dp[m - 1][n - 1];
    }
}

```



## [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

 

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

 

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成

解题思路

先把字符串变成char数组，然后逐一遍历字母，

用中心扩散法，分为两种情况，一种是默认当前子字符串为奇数，当前字母为中间字母，左右指针都为当前字母

另一种是默认当前子字符串为偶数，left为当前字母，right为下一个字母

再构造一个方法，从中间外面判断每个字母是否相等，再返回子字符串的长度

取两种方法最大的长度，然后跟主函数变量 maxLen进行对比，看是否有更长的字符串出现

然后更新当前字母的位置和字符串长度

```java
begin = i - (maxLen - 1) / 2;  //注意这里因为i是处于字符串中间，而且有奇和偶两种情况，所以需要这个公式计算出起始位置
							//(maxLen - 1)是为了考虑偶数情况，因为是int所以会向下取整
							//可以看成	maxLen/2	就为子字符串一半的长度
							//		i减去	(maxLen - 1) / 2	就等于	初始长度
```

//    假设有长度为9的字符串01***234567***89,中间第一个值为4，长度为6为偶数，那么起始位置就为2
begin = 4 - (6 - 1) / 2     
 	= 4 - 2      
	= 2

代码如下

```java
class Solution {
public String longestPalindrome(String s) {
    // 如果字符串长度小于2，直接返回原字符串
    if (s.length() < 2) {
        return s;
    }
    
    int maxLen = 0; // 最长回文子串的长度
    int begin = 0; // 最长回文子串的起始位置
    char[] array = s.toCharArray(); // 将字符串转换为字符数组
    // 遍历字符串中的每个字符
    for (int i = 0; i < s.length() - 1; i++) {
        // 以当前字符为中心，分别向两边扩展，得到奇数长度的回文子串长度
        int oddLen = expandAroundCenter(array, i, i);
        // 以当前字符和下一个字符之间为中心，分别向两边扩展，得到偶数长度的回文子串长度
        int evenLen = expandAroundCenter(array, i, i + 1);
        // 取奇数长度和偶数长度的最大值作为当前回文子串的长度
        int curMaxLen = Math.max(oddLen, evenLen);
        // 如果当前回文子串长度大于之前记录的最大长度，则更新最大长度和起始位置
        if (curMaxLen > maxLen) {
            maxLen = curMaxLen;
            begin = i - (maxLen - 1) / 2;
        }
    }
    // 根据起始位置和最大长度截取最长回文子串并返回,这个为闭区间，如果为，2，6，那么包括2和8（2+6）
    return s.substring(begin, begin + maxLen);
}

// 在字符数组中以left和right为中心，向两边扩展，返回回文子串的长度
public int expandAroundCenter(char[] array, int left, int right) {
    // 当左右指针对应的字符相等且左指针不小于0，右指针不大于数组长度时，循环继续
    while (left >= 0 && right < array.length && array[left] == array[right]) {
        left--; // 向左移动左指针
        right++; // 向右移动右指针
    }
    // 返回回文子串的长度，长度为(right - 1) - (left + 1) + 1 = right - left - 1
    return (right - 1) - (left + 1) + 1;
    }
}
```



## [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)



给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

 

**示例 1：**

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

**示例 2：**

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```

**示例 3：**

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```

 

**提示：**

- `1 <= text1.length, text2.length <= 1000`
- `text1` 和 `text2` 仅由小写英文字符组成。

解题思路

创建一个二维dp数组存储当前相同最长子字符串长度

在动态规划的过程中，`dp[i][j]` 表示的是字符串 `text1` 的前 `i` 个字符和字符串 `text2` 的前 `j` 个字符之间的最长公共子序列的长度。当 `text1[i]` 和 `text2[j]` 相等时，说明可以将这两个字符同时添加到最长公共子序列中，因此最长公共子序列的长度为 `dp[i-1][j-1] + 1`。

但是如果 `text1[i]` 和 `text2[j]` 不相等，那么无法同时将这两个字符添加到最长公共子序列中。这时我们有两种选择：

1. 不包含 `text1[i]`，最长公共子序列长度为 `dp[i-1][j]`；
2. 不包含 `text2[j]`，最长公共子序列长度为 `dp[i][j-1]`。

因此，我们选择其中较大的值作为 `dp[i][j]` 的值，保证了 `dp[i][j]` 中记录的是当前位置的最长公共子序列长度。

对角线为上一个字母的保存的最大长度，而左上的字母为当前位置的最长公共子序列长度

```java
//    示例 1：
//
//    输入：text1 = "abcde", text2 = "ace"
//    输出：3
//    解释：最长公共子序列是 "ace" ，它的长度为 3 。
//	  int[][] dp = new int[6][4];
```

|          | **null** | **a** | **c** | **e** |
| :------- | :------- | :---- | ----- | ----- |
| **null** | 0        | 0     | 0     | 0     |
| **a**    | 0        | 1     | 1     | 1     |
| **b**    | 0        | 1     | 1     | 1     |
| **c**    | 0        | 1     | 2     | 2     |
| **d**    | 0        | 1     | 2     | 2     |
| **e**    | 0        | 1     | 2     | 3     |

代码如下

```java
class Solution {
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length(); // 获取text1的长度
    int n = text2.length(); // 获取text2的长度
    int[][] dp = new int[m + 1][n + 1]; // 创建一个二维数组dp，dp[i][j]表示text1的前i个字符和text2的前j个字符中的最长公共子序列的长度
    // 初始化边界条件
    for (int i = 0; i <= m; i++) {
        dp[i][0] = 0; // 当text2为空串时，最长公共子序列的长度为0
    }
    for (int j = 0; j <= n; j++) {
        dp[0][j] = 0; // 当text1为空串时，最长公共子序列的长度为0
    }
    // 动态规划计算
    for (int i = 1; i <= m; i++) {			//注意小于等于，因为i-1
        for (int j = 1; j <= n; j++) {		//注意小于等于，因为j-1
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                // 如果text1的第i个字符和text2的第j个字符相等，则最长公共子序列的长度等于dp[i-1][j-1]+1
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                // 如果text1的第i个字符和text2的第j个字符不相等，则最长公共子序列的长度等于dp[i-1][j]和dp[i][j-1]中的较大值
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n]; // 返回text1和text2的最长公共子序列的长度
}
}
```



## [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符 

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

 

**提示：**

- `0 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 由小写英文字母组成

解题思路

这道题和上题差不多，也是要创建一个二维数组dp，来保存当前的最少操作数

不过这道题，字母相同有一个选择，字母不同有三个选择

```java
//    示例 1：
//
//    输入：word1 = "abcde", word2= "ace"
//    输出：2
//    解释：删除b和d是最少操作数 。
//	  int[][] dp = new int[6][4];
```

```
可以很直观的看见，word1每个字母为一行，word2每个字母为一列
第一列初始化操作是删除字符串，就是dp[i - 1][j] + 1。变成空串
第一行初始化操作是增加字符串，就是dp[i][j - 1] + 1。变成一样的字符串
那么不相等的两个操作的dp函数式就已经得到了,分别为删除和增加
如果 word1 的第 i 个字符等于 word2 的第 j 个字符，则不需要进行操作，即
dp[i][j] = dp[i - 1][j - 1]。
如果 word1 的第 i 个字符不等于 word2 的第 j 个字符，则可以通过三种操作实现：
替换操作：将 word1 的第 i 个字符替换为 word2 的第 j 个字符，操作数为
dp[i - 1][j - 1] + 1。
删除操作：删除 word1 的第 i 个字符，操作数为 		
dp[i - 1][j] + 1。
插入操作：在 word1 的第 i 个字符后插入与 word2 的第 j 个字符相同的字符，操作数为 
dp[i][j - 1] + 1。
取这三种操作中的最小值作为 dp[i][j] 的值。
```

| word1为下，word2为右 | null | a         | c         | e         |
| -------------------- | ---- | --------- | --------- | --------- |
| null                 | 0    | 1         | （OPT1）2 | 3         |
| a                    | 1    | （OPT2）0 | （OPT0）1 | （OPT4）2 |
| b                    | 2    | 1         | （OPT5）1 | （OPT3）2 |
| c                    | 3    | 2         | 1         | 2         |
| d                    | 4    | 3         | 2         | 2         |
| e                    | 5    | 4         | 3         | 2         |

```java
假设已经遍历到（OPT0）不相等，有三个操作
删除：1.对应（OPT1）word1本来为空字符串，word2为ac，word1必须添加两个字符串a和c，word1就等于ac等于word2，两步操作，但是（OPT0）时word1=aca，word1要等于word2，aca减去a，那么还要删除a，三步操作
添加：2.对应（OPT2）word1为a,word2为a,不需要操作，但是（OPT0）时，word2变成ac，word1添加c变成ac，ac=ac，一步操作
替换：3.替换操作无效，不用管，后面举例替换
取三个步骤最小值，也就是说当前（OPT0）状态是,删除c之后，word1=word2=a，一步操作
遍历到（OPT3）不相等，有三个操作
删除：1.可以看到（OPT4）为（OPT0）的 ac=ac，（OPT4）ac！=ace， 需要添加e，ace=ace，（OPT3）时aceb!=ace,删除b,ace=ace，共三步操作
添加：2.可以看到（OPT5）为（OPT2）的 a=a ,ab!=ac替换后的ac=ac，（OPT3）时ac！=ace,添加e，ace=ace，共两步操作
替换：3.对应（OPT0）word1为a,word2为a，相等，有一步操作，但是（OPT3）时都加了一个字母，word1=ab，word2=ae，word1要等于word2，ab替换为ae，b替换为e，一步操作，加上（OPT0）一步操作，共两步操作
删除为三步,添加和替换都为两步，选择最少的状态填充进dp数组
当前字符如果相等就不用进行任何操作，比如（OPT2），之前都为空，都添加一个字母，a=a，无需任何操作
```



代码如下

```java
class Solution {
public int minDistance(String word1, String word2) {
    int m = word1.length(); // 获取 word1 的长度
    int n = word2.length(); // 获取 word2 的长度
    
    int[][] dp = new int[m + 1][n + 1]; // 创建二维数组 dp，大小为 (m+1) * (n+1)，用于存储状态转移结果
    // 边界条件：一个字符串为空时，转换成另一个字符串需要的操作次数就是另一个字符串的长度
    for(int i =1;i<=m;i++){
        dp[i][0]= dp[i-1][0]+1;
    }//初始化
    for(int k =1;k<=n;k++){
        dp[0][k]= dp[0][k-1]+1;
    }
    // 填充dp数组
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) { // 如果当前字符相等，则不需要操作
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                int insert = dp[i][j - 1] + 1; // 插入操作：在 word1 的当前位置插入一个字符
                int delete = dp[i - 1][j] + 1; // 删除操作：删除 word1 的当前字符
                int replace = dp[i - 1][j - 1] + 1; // 替换操作：将 word1 的当前字符替换为 word2 的当前字符
                dp[i][j] = Math.min(Math.min(insert, delete), replace); // 取三种操作中的最小值作为当前状态的最小操作数
            }
        }
    }
    
    return dp[m][n]; // 返回将 word1 转换成 word2 所需的最少操作数
    }
}
```

# 十七，技巧

## [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

 

**示例 1 ：**

```
输入：nums = [2,2,1]
输出：1
```

**示例 2 ：**

```
输入：nums = [4,1,2,1,2]
输出：4
```

**示例 3 ：**

```
输入：nums = [1]
输出：1
```

 

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-3 * 104 <= nums[i] <= 3 * 104`
- 除了某个元素只出现一次以外，其余每个元素均出现两次。

解题思路

按位异或操作具有以下性质：

1. a ^ a = 0
2. a ^ 0 = a
3. a ^ b = b ^ a
4. (a ^ b) ^ c = a ^ (b ^ c)

例如：

- 0 ^ 0 = 0
- 0 ^ 1 = 1
- 1 ^ 0 = 1
- 1 ^ 1 = 0

这些性质使得按位异或操作在许多算法和数据处理中都很有用。

代码如下

```java
class Solution {
    public int singleNumber(int[] nums) {
        int x = 0; // 初始化结果变量为0，因为任何数和0异或都等于它本身
        for(int num : nums) // 遍历数组中的每个数字
            x ^= num; // 对结果变量进行异或运算，相同的数字异或结果为0，不同的数字异或结果为该数字本身
        return x; // 返回结果变量，即只出现一次的数字
    }
}
```



## [169. 多数元素](https://leetcode.cn/problems/majority-element/)

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**

```
输入：nums = [2,2,1,1,1,2,2]
输出：2
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 5 * 104`
- `-109 <= nums[i] <= 109`

 

**进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

解题思路

既然有数字超过一半，那么他的出现次数肯定大于n/2，最后出现的数一定是它

代码如下

```java
class Solution {
    public int majorityElement(int[] nums) {
        int x = 0; // 初始化候选元素
        int v = 0; // 初始化候选元素的出现次数
        for(int num : nums) { // 遍历数组中的每个数字
            if(v == 0) // 如果候选元素的出现次数为0
                x = num; // 则将当前数字作为新的候选元素
            v += num == x ? 1 : -1; // 更新候选元素的出现次数，如果当前数字与候选元素相同，则加1，否则减1
        }
        return x; // 返回出现次数超过数组长度一半的元素
    }
}

```

## [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

 

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 `0`、`1` 或 `2`

 

**进阶：**

- 你能想出一个仅使用常数空间的一趟扫描算法吗？

可以使用两个指针 `n0` 和 `n1` 来记录数组中 0 和 1 的位置。在一次遍历中，它将遇到的每个元素都置为 2，并根据元素的值将其放置在合适的位置。

代码如下

```java
class Solution {
    public void sortColors(int[] nums) {
        // 初始化两个指针，用于记录 0 和 1 的位置
        int n0 = 0, n1 = 0;
        // 遍历数组
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            // 将当前元素置为 2
            nums[i] = 2;
            // 如果当前元素小于 2，则说明它不是 2，即可以放在 1 的位置上
            if (num < 2) {
                nums[n1++] = 1;
            }
            // 如果当前元素小于 1，则说明它不是 1，即可以放在 0 的位置上
            if (num < 1) {
                nums[n0++] = 0;
            }
        }
    }
}
```



## [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`

解题思路

nums = [1,2,7,4,3,1],

1. 第一步: 倒序遍历数组, 找出第一组: 前一个数比后一个数小的两个数, 即[2, 7]
2. 2所处的这个位置就是需要找出比它稍微大的数的位置;
3. 我们从[7,4,3,1]中找出比2大的数中的最小值, 也就是3, 找到后跟2交换即可;; 当然了, 如果没找到的话, 直接跳到第5步, 直接升序排列输出.
4. 目前nums=[1,3,7,4,2,1], 不用我说你们也看出来还不算下一个排列
5. 对3后面的数, 升序排列, 即最终结果: nums = [1,3,1,2,4,7]

代码如下

```java
class Solution {
    public void nextPermutation(int[] nums) {
        //1. 1,2,3 ==> 1,3,2
        //1. 倒序遍历, 找到第一个数, 这个数比后面的数小;
        //2. 继续倒序遍历, 找到一个比上面的数大的数;
        //3. 交换
        //4. 把1中的这个数后面的数全部递增排列, 因为在1后面的数时递减排列的, 所以首尾交换即可获得升序排列       
        int len = nums.length;
        int i = len - 2; //i = len - 2 是为了防止下面nums[i + 1]越界!
        //1. 倒序遍历, 找到第一个数, 这个数比后面的数小;
        while(i >= 0){
            if(nums[i] < nums[i + 1])break;
            --i;
        }
        //2. 继续倒序遍历, 找到一个上面的数大的数
        if(i >= 0){						//记得判断i>=0再执行以下逻辑,如果是54321，那么就没有执行break，i=-1；
            int j = len - 1;
            while(j >= 0){
                if(nums[j] > nums[i])break;
                --j;
            }
            //3. 交换i和j
            swap(nums, i, j); //交换i和j的位置
        }
         
        //4. 将 i后面的数升序排列, 只需要对撞双指针交换即可(因为i后面的数时降序的)
        reverse(nums, i + 1, len - 1);
    }
// 交换数组中的两个元素
    public void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
    // 将数组中从 left 到 right 之间的元素逆序
    public void reverse(int[] nums, int left, int right) {
        while (left < right) {						//记得left<right
            swap(nums, left, right);
            ++left;
            --right;								//指针记得相加相减
        }
    }
}
```



## [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

 

**示例 1：**

```
输入：nums = [1,3,4,2,2]
输出：2
```

**示例 2：**

```
输入：nums = [3,1,3,4,2]
输出：3
```

**示例 3 :**

```
输入：nums = [3,3,3,3,3]
输出：3
```

 

 

**提示：**

- `1 <= n <= 105`
- `nums.length == n + 1`
- `1 <= nums[i] <= n`
- `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**

 

**进阶：**

- 如何证明 `nums` 中至少存在一个重复的数字?
- 你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？

从理论上讲，数组中如果有重复的数，那么就会产生多对一的映射，这样，形成的链表就一定会有环路了，

综上
1.数组中有一个重复的整数 <==> 链表中存在环
2.找到数组中的重复整数 <==> 找到链表的环入口

![287.png](https://pic.leetcode-cn.com/999e055b41e499d9ac704abada4a1b8e6697374fdfedc17d06b0e8aa10a8f8f6-287.png)

当快慢指针相等时，意味着它们进入了环中，并且相遇点不一定就是环的起点。但是，可以肯定的是，它们相遇之后的步数总是刚好等于环的长度的倍数。

假设慢指针slow和快指针fast在环内相遇，此时慢指针slow已经在环中移动了k步，那么快指针fast就已经在环中移动了2k步。设环的长度为L，那么有：

K mod  L = 2K mod  L

因此，快指针fast比慢指针slow多走了环的整数倍。而在它们相遇后，如果我们将其中一个指针移到链表头部，然后两个指针同时以每次一步的速度移动，它们再次相遇的地方就是环的起点。因为快指针相遇时，它在环中移动了整数倍的环长度，所以移动相同的步数后，它们会再次相遇，并且这次相遇点就是环的起点。

因此，通过这种方式，我们可以找到环的起点，也就是重复的元素所在位置。

代码如下

```java
class Solution {
    public int findDuplicate(int[] nums) {
        // 初始化快慢指针
        int slow = nums[0];
        int fast = nums[0];
        // 使用快慢指针找到相遇点
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        // 重新初始化 slow，并让 slow 和 fast 每次向后移动一步，直到再次相遇
        slow = nums[0];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        // 返回相遇点的值
        return slow;
    }
}
```



